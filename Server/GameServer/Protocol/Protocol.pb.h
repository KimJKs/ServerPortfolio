// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_ATTACK;
struct C_ATTACKDefaultTypeInternal;
extern C_ATTACKDefaultTypeInternal _C_ATTACK_default_instance_;
class C_CHAT;
struct C_CHATDefaultTypeInternal;
extern C_CHATDefaultTypeInternal _C_CHAT_default_instance_;
class C_DROP_ITEM;
struct C_DROP_ITEMDefaultTypeInternal;
extern C_DROP_ITEMDefaultTypeInternal _C_DROP_ITEM_default_instance_;
class C_ENTER_GAME;
struct C_ENTER_GAMEDefaultTypeInternal;
extern C_ENTER_GAMEDefaultTypeInternal _C_ENTER_GAME_default_instance_;
class C_ENTER_ROOM;
struct C_ENTER_ROOMDefaultTypeInternal;
extern C_ENTER_ROOMDefaultTypeInternal _C_ENTER_ROOM_default_instance_;
class C_LEAVE_GAME;
struct C_LEAVE_GAMEDefaultTypeInternal;
extern C_LEAVE_GAMEDefaultTypeInternal _C_LEAVE_GAME_default_instance_;
class C_LOGIN;
struct C_LOGINDefaultTypeInternal;
extern C_LOGINDefaultTypeInternal _C_LOGIN_default_instance_;
class C_MOVE;
struct C_MOVEDefaultTypeInternal;
extern C_MOVEDefaultTypeInternal _C_MOVE_default_instance_;
class C_PONG;
struct C_PONGDefaultTypeInternal;
extern C_PONGDefaultTypeInternal _C_PONG_default_instance_;
class C_POS_SYNC;
struct C_POS_SYNCDefaultTypeInternal;
extern C_POS_SYNCDefaultTypeInternal _C_POS_SYNC_default_instance_;
class C_PURCHASE_MARKET_ITEM;
struct C_PURCHASE_MARKET_ITEMDefaultTypeInternal;
extern C_PURCHASE_MARKET_ITEMDefaultTypeInternal _C_PURCHASE_MARKET_ITEM_default_instance_;
class C_REGISTER_MARKET_ITEM;
struct C_REGISTER_MARKET_ITEMDefaultTypeInternal;
extern C_REGISTER_MARKET_ITEMDefaultTypeInternal _C_REGISTER_MARKET_ITEM_default_instance_;
class C_REQUEST_MARKET_ITEM_LIST;
struct C_REQUEST_MARKET_ITEM_LISTDefaultTypeInternal;
extern C_REQUEST_MARKET_ITEM_LISTDefaultTypeInternal _C_REQUEST_MARKET_ITEM_LIST_default_instance_;
class C_SIGN_UP;
struct C_SIGN_UPDefaultTypeInternal;
extern C_SIGN_UPDefaultTypeInternal _C_SIGN_UP_default_instance_;
class C_SKILL;
struct C_SKILLDefaultTypeInternal;
extern C_SKILLDefaultTypeInternal _C_SKILL_default_instance_;
class C_USE_ITEM;
struct C_USE_ITEMDefaultTypeInternal;
extern C_USE_ITEMDefaultTypeInternal _C_USE_ITEM_default_instance_;
class C_WHISPER;
struct C_WHISPERDefaultTypeInternal;
extern C_WHISPERDefaultTypeInternal _C_WHISPER_default_instance_;
class S_ADD_ITEM;
struct S_ADD_ITEMDefaultTypeInternal;
extern S_ADD_ITEMDefaultTypeInternal _S_ADD_ITEM_default_instance_;
class S_ATTACK;
struct S_ATTACKDefaultTypeInternal;
extern S_ATTACKDefaultTypeInternal _S_ATTACK_default_instance_;
class S_CHANGE_CURRENCY;
struct S_CHANGE_CURRENCYDefaultTypeInternal;
extern S_CHANGE_CURRENCYDefaultTypeInternal _S_CHANGE_CURRENCY_default_instance_;
class S_CHANGE_ITEM_INFO;
struct S_CHANGE_ITEM_INFODefaultTypeInternal;
extern S_CHANGE_ITEM_INFODefaultTypeInternal _S_CHANGE_ITEM_INFO_default_instance_;
class S_CHAT;
struct S_CHATDefaultTypeInternal;
extern S_CHATDefaultTypeInternal _S_CHAT_default_instance_;
class S_DESPAWN;
struct S_DESPAWNDefaultTypeInternal;
extern S_DESPAWNDefaultTypeInternal _S_DESPAWN_default_instance_;
class S_DIE;
struct S_DIEDefaultTypeInternal;
extern S_DIEDefaultTypeInternal _S_DIE_default_instance_;
class S_ENTER_ROOM;
struct S_ENTER_ROOMDefaultTypeInternal;
extern S_ENTER_ROOMDefaultTypeInternal _S_ENTER_ROOM_default_instance_;
class S_ITEM_LIST;
struct S_ITEM_LISTDefaultTypeInternal;
extern S_ITEM_LISTDefaultTypeInternal _S_ITEM_LIST_default_instance_;
class S_LEAVE_ROOM;
struct S_LEAVE_ROOMDefaultTypeInternal;
extern S_LEAVE_ROOMDefaultTypeInternal _S_LEAVE_ROOM_default_instance_;
class S_LOGIN;
struct S_LOGINDefaultTypeInternal;
extern S_LOGINDefaultTypeInternal _S_LOGIN_default_instance_;
class S_MARKET_ITEM_LIST;
struct S_MARKET_ITEM_LISTDefaultTypeInternal;
extern S_MARKET_ITEM_LISTDefaultTypeInternal _S_MARKET_ITEM_LIST_default_instance_;
class S_MOVE;
struct S_MOVEDefaultTypeInternal;
extern S_MOVEDefaultTypeInternal _S_MOVE_default_instance_;
class S_PING;
struct S_PINGDefaultTypeInternal;
extern S_PINGDefaultTypeInternal _S_PING_default_instance_;
class S_PURCHASE_MARKET_ITEM;
struct S_PURCHASE_MARKET_ITEMDefaultTypeInternal;
extern S_PURCHASE_MARKET_ITEMDefaultTypeInternal _S_PURCHASE_MARKET_ITEM_default_instance_;
class S_REMOVE_ITEM;
struct S_REMOVE_ITEMDefaultTypeInternal;
extern S_REMOVE_ITEMDefaultTypeInternal _S_REMOVE_ITEM_default_instance_;
class S_SKILL;
struct S_SKILLDefaultTypeInternal;
extern S_SKILLDefaultTypeInternal _S_SKILL_default_instance_;
class S_SPAWN;
struct S_SPAWNDefaultTypeInternal;
extern S_SPAWNDefaultTypeInternal _S_SPAWN_default_instance_;
class S_UPDATE_RESOURCE;
struct S_UPDATE_RESOURCEDefaultTypeInternal;
extern S_UPDATE_RESOURCEDefaultTypeInternal _S_UPDATE_RESOURCE_default_instance_;
class S_USER_STATUS;
struct S_USER_STATUSDefaultTypeInternal;
extern S_USER_STATUSDefaultTypeInternal _S_USER_STATUS_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_ATTACK* Arena::CreateMaybeMessage<::Protocol::C_ATTACK>(Arena*);
template<> ::Protocol::C_CHAT* Arena::CreateMaybeMessage<::Protocol::C_CHAT>(Arena*);
template<> ::Protocol::C_DROP_ITEM* Arena::CreateMaybeMessage<::Protocol::C_DROP_ITEM>(Arena*);
template<> ::Protocol::C_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::C_ENTER_GAME>(Arena*);
template<> ::Protocol::C_ENTER_ROOM* Arena::CreateMaybeMessage<::Protocol::C_ENTER_ROOM>(Arena*);
template<> ::Protocol::C_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::C_LEAVE_GAME>(Arena*);
template<> ::Protocol::C_LOGIN* Arena::CreateMaybeMessage<::Protocol::C_LOGIN>(Arena*);
template<> ::Protocol::C_MOVE* Arena::CreateMaybeMessage<::Protocol::C_MOVE>(Arena*);
template<> ::Protocol::C_PONG* Arena::CreateMaybeMessage<::Protocol::C_PONG>(Arena*);
template<> ::Protocol::C_POS_SYNC* Arena::CreateMaybeMessage<::Protocol::C_POS_SYNC>(Arena*);
template<> ::Protocol::C_PURCHASE_MARKET_ITEM* Arena::CreateMaybeMessage<::Protocol::C_PURCHASE_MARKET_ITEM>(Arena*);
template<> ::Protocol::C_REGISTER_MARKET_ITEM* Arena::CreateMaybeMessage<::Protocol::C_REGISTER_MARKET_ITEM>(Arena*);
template<> ::Protocol::C_REQUEST_MARKET_ITEM_LIST* Arena::CreateMaybeMessage<::Protocol::C_REQUEST_MARKET_ITEM_LIST>(Arena*);
template<> ::Protocol::C_SIGN_UP* Arena::CreateMaybeMessage<::Protocol::C_SIGN_UP>(Arena*);
template<> ::Protocol::C_SKILL* Arena::CreateMaybeMessage<::Protocol::C_SKILL>(Arena*);
template<> ::Protocol::C_USE_ITEM* Arena::CreateMaybeMessage<::Protocol::C_USE_ITEM>(Arena*);
template<> ::Protocol::C_WHISPER* Arena::CreateMaybeMessage<::Protocol::C_WHISPER>(Arena*);
template<> ::Protocol::S_ADD_ITEM* Arena::CreateMaybeMessage<::Protocol::S_ADD_ITEM>(Arena*);
template<> ::Protocol::S_ATTACK* Arena::CreateMaybeMessage<::Protocol::S_ATTACK>(Arena*);
template<> ::Protocol::S_CHANGE_CURRENCY* Arena::CreateMaybeMessage<::Protocol::S_CHANGE_CURRENCY>(Arena*);
template<> ::Protocol::S_CHANGE_ITEM_INFO* Arena::CreateMaybeMessage<::Protocol::S_CHANGE_ITEM_INFO>(Arena*);
template<> ::Protocol::S_CHAT* Arena::CreateMaybeMessage<::Protocol::S_CHAT>(Arena*);
template<> ::Protocol::S_DESPAWN* Arena::CreateMaybeMessage<::Protocol::S_DESPAWN>(Arena*);
template<> ::Protocol::S_DIE* Arena::CreateMaybeMessage<::Protocol::S_DIE>(Arena*);
template<> ::Protocol::S_ENTER_ROOM* Arena::CreateMaybeMessage<::Protocol::S_ENTER_ROOM>(Arena*);
template<> ::Protocol::S_ITEM_LIST* Arena::CreateMaybeMessage<::Protocol::S_ITEM_LIST>(Arena*);
template<> ::Protocol::S_LEAVE_ROOM* Arena::CreateMaybeMessage<::Protocol::S_LEAVE_ROOM>(Arena*);
template<> ::Protocol::S_LOGIN* Arena::CreateMaybeMessage<::Protocol::S_LOGIN>(Arena*);
template<> ::Protocol::S_MARKET_ITEM_LIST* Arena::CreateMaybeMessage<::Protocol::S_MARKET_ITEM_LIST>(Arena*);
template<> ::Protocol::S_MOVE* Arena::CreateMaybeMessage<::Protocol::S_MOVE>(Arena*);
template<> ::Protocol::S_PING* Arena::CreateMaybeMessage<::Protocol::S_PING>(Arena*);
template<> ::Protocol::S_PURCHASE_MARKET_ITEM* Arena::CreateMaybeMessage<::Protocol::S_PURCHASE_MARKET_ITEM>(Arena*);
template<> ::Protocol::S_REMOVE_ITEM* Arena::CreateMaybeMessage<::Protocol::S_REMOVE_ITEM>(Arena*);
template<> ::Protocol::S_SKILL* Arena::CreateMaybeMessage<::Protocol::S_SKILL>(Arena*);
template<> ::Protocol::S_SPAWN* Arena::CreateMaybeMessage<::Protocol::S_SPAWN>(Arena*);
template<> ::Protocol::S_UPDATE_RESOURCE* Arena::CreateMaybeMessage<::Protocol::S_UPDATE_RESOURCE>(Arena*);
template<> ::Protocol::S_USER_STATUS* Arena::CreateMaybeMessage<::Protocol::S_USER_STATUS>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class C_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LOGIN) */ {
 public:
  inline C_LOGIN() : C_LOGIN(nullptr) {}
  ~C_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR C_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOGIN(const C_LOGIN& from);
  C_LOGIN(C_LOGIN&& from) noexcept
    : C_LOGIN() {
    *this = ::std::move(from);
  }

  inline C_LOGIN& operator=(const C_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOGIN& operator=(C_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOGIN* internal_default_instance() {
    return reinterpret_cast<const C_LOGIN*>(
               &_C_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_LOGIN& a, C_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_LOGIN& from) {
    C_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LOGIN";
  }
  protected:
  explicit C_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SIGN_UP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SIGN_UP) */ {
 public:
  inline C_SIGN_UP() : C_SIGN_UP(nullptr) {}
  ~C_SIGN_UP() override;
  explicit PROTOBUF_CONSTEXPR C_SIGN_UP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SIGN_UP(const C_SIGN_UP& from);
  C_SIGN_UP(C_SIGN_UP&& from) noexcept
    : C_SIGN_UP() {
    *this = ::std::move(from);
  }

  inline C_SIGN_UP& operator=(const C_SIGN_UP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SIGN_UP& operator=(C_SIGN_UP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SIGN_UP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SIGN_UP* internal_default_instance() {
    return reinterpret_cast<const C_SIGN_UP*>(
               &_C_SIGN_UP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(C_SIGN_UP& a, C_SIGN_UP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SIGN_UP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SIGN_UP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SIGN_UP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SIGN_UP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SIGN_UP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_SIGN_UP& from) {
    C_SIGN_UP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SIGN_UP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SIGN_UP";
  }
  protected:
  explicit C_SIGN_UP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SIGN_UP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOGIN) */ {
 public:
  inline S_LOGIN() : S_LOGIN(nullptr) {}
  ~S_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR S_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOGIN(const S_LOGIN& from);
  S_LOGIN(S_LOGIN&& from) noexcept
    : S_LOGIN() {
    *this = ::std::move(from);
  }

  inline S_LOGIN& operator=(const S_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOGIN& operator=(S_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOGIN* internal_default_instance() {
    return reinterpret_cast<const S_LOGIN*>(
               &_S_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(S_LOGIN& a, S_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LOGIN& from) {
    S_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOGIN";
  }
  protected:
  explicit S_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .Protocol.PlayerInfo playerInfo = 2;
  bool has_playerinfo() const;
  private:
  bool _internal_has_playerinfo() const;
  public:
  void clear_playerinfo();
  const ::Protocol::PlayerInfo& playerinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PlayerInfo* release_playerinfo();
  ::Protocol::PlayerInfo* mutable_playerinfo();
  void set_allocated_playerinfo(::Protocol::PlayerInfo* playerinfo);
  private:
  const ::Protocol::PlayerInfo& _internal_playerinfo() const;
  ::Protocol::PlayerInfo* _internal_mutable_playerinfo();
  public:
  void unsafe_arena_set_allocated_playerinfo(
      ::Protocol::PlayerInfo* playerinfo);
  ::Protocol::PlayerInfo* unsafe_arena_release_playerinfo();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PlayerInfo* playerinfo_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENTER_GAME) */ {
 public:
  inline C_ENTER_GAME() : C_ENTER_GAME(nullptr) {}
  ~C_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER_GAME(const C_ENTER_GAME& from);
  C_ENTER_GAME(C_ENTER_GAME&& from) noexcept
    : C_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline C_ENTER_GAME& operator=(const C_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER_GAME& operator=(C_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const C_ENTER_GAME*>(
               &_C_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(C_ENTER_GAME& a, C_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ENTER_GAME& from) {
    C_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTER_GAME";
  }
  protected:
  explicit C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectInfoFieldNumber = 3,
    kIsDummyFieldNumber = 1,
    kDummyNumberFieldNumber = 2,
  };
  // .Protocol.ObjectInfo objectInfo = 3;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // bool isDummy = 1;
  void clear_isdummy();
  bool isdummy() const;
  void set_isdummy(bool value);
  private:
  bool _internal_isdummy() const;
  void _internal_set_isdummy(bool value);
  public:

  // int32 dummyNumber = 2;
  void clear_dummynumber();
  int32_t dummynumber() const;
  void set_dummynumber(int32_t value);
  private:
  int32_t _internal_dummynumber() const;
  void _internal_set_dummynumber(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* objectinfo_;
    bool isdummy_;
    int32_t dummynumber_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ENTER_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENTER_ROOM) */ {
 public:
  inline C_ENTER_ROOM() : C_ENTER_ROOM(nullptr) {}
  ~C_ENTER_ROOM() override;
  explicit PROTOBUF_CONSTEXPR C_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER_ROOM(const C_ENTER_ROOM& from);
  C_ENTER_ROOM(C_ENTER_ROOM&& from) noexcept
    : C_ENTER_ROOM() {
    *this = ::std::move(from);
  }

  inline C_ENTER_ROOM& operator=(const C_ENTER_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER_ROOM& operator=(C_ENTER_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER_ROOM* internal_default_instance() {
    return reinterpret_cast<const C_ENTER_ROOM*>(
               &_C_ENTER_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_ENTER_ROOM& a, C_ENTER_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTER_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTER_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENTER_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ENTER_ROOM& from) {
    C_ENTER_ROOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTER_ROOM";
  }
  protected:
  explicit C_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapIdFieldNumber = 1,
  };
  // int32 mapId = 1;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTER_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t mapid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ENTER_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENTER_ROOM) */ {
 public:
  inline S_ENTER_ROOM() : S_ENTER_ROOM(nullptr) {}
  ~S_ENTER_ROOM() override;
  explicit PROTOBUF_CONSTEXPR S_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTER_ROOM(const S_ENTER_ROOM& from);
  S_ENTER_ROOM(S_ENTER_ROOM&& from) noexcept
    : S_ENTER_ROOM() {
    *this = ::std::move(from);
  }

  inline S_ENTER_ROOM& operator=(const S_ENTER_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTER_ROOM& operator=(S_ENTER_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTER_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTER_ROOM* internal_default_instance() {
    return reinterpret_cast<const S_ENTER_ROOM*>(
               &_S_ENTER_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_ENTER_ROOM& a, S_ENTER_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTER_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTER_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENTER_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENTER_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENTER_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENTER_ROOM& from) {
    S_ENTER_ROOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTER_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENTER_ROOM";
  }
  protected:
  explicit S_ENTER_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
    kMapIdFieldNumber = 2,
  };
  // .Protocol.ObjectInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ObjectInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_player();
  ::Protocol::ObjectInfo* mutable_player();
  void set_allocated_player(::Protocol::ObjectInfo* player);
  private:
  const ::Protocol::ObjectInfo& _internal_player() const;
  ::Protocol::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ObjectInfo* player);
  ::Protocol::ObjectInfo* unsafe_arena_release_player();

  // int32 mapId = 2;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENTER_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* player_;
    int32_t mapid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_LEAVE_GAME) */ {
 public:
  inline C_LEAVE_GAME() : C_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LEAVE_GAME(const C_LEAVE_GAME& from);
  C_LEAVE_GAME(C_LEAVE_GAME&& from) noexcept
    : C_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline C_LEAVE_GAME& operator=(const C_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LEAVE_GAME& operator=(C_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const C_LEAVE_GAME*>(
               &_C_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C_LEAVE_GAME& a, C_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LEAVE_GAME";
  }
  protected:
  explicit C_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LEAVE_ROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LEAVE_ROOM) */ {
 public:
  inline S_LEAVE_ROOM() : S_LEAVE_ROOM(nullptr) {}
  ~S_LEAVE_ROOM() override;
  explicit PROTOBUF_CONSTEXPR S_LEAVE_ROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEAVE_ROOM(const S_LEAVE_ROOM& from);
  S_LEAVE_ROOM(S_LEAVE_ROOM&& from) noexcept
    : S_LEAVE_ROOM() {
    *this = ::std::move(from);
  }

  inline S_LEAVE_ROOM& operator=(const S_LEAVE_ROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEAVE_ROOM& operator=(S_LEAVE_ROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEAVE_ROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEAVE_ROOM* internal_default_instance() {
    return reinterpret_cast<const S_LEAVE_ROOM*>(
               &_S_LEAVE_ROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_LEAVE_ROOM& a, S_LEAVE_ROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEAVE_ROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEAVE_ROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LEAVE_ROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LEAVE_ROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LEAVE_ROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LEAVE_ROOM& from) {
    S_LEAVE_ROOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LEAVE_ROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LEAVE_ROOM";
  }
  protected:
  explicit S_LEAVE_ROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // int32 objectId = 1;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LEAVE_ROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t objectid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SPAWN) */ {
 public:
  inline S_SPAWN() : S_SPAWN(nullptr) {}
  ~S_SPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWN(const S_SPAWN& from);
  S_SPAWN(S_SPAWN&& from) noexcept
    : S_SPAWN() {
    *this = ::std::move(from);
  }

  inline S_SPAWN& operator=(const S_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWN& operator=(S_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWN* internal_default_instance() {
    return reinterpret_cast<const S_SPAWN*>(
               &_S_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_SPAWN& a, S_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SPAWN& from) {
    S_SPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SPAWN";
  }
  protected:
  explicit S_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 1,
  };
  // repeated .Protocol.ObjectInfo objects = 1;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::Protocol::ObjectInfo* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_objects();
  private:
  const ::Protocol::ObjectInfo& _internal_objects(int index) const;
  ::Protocol::ObjectInfo* _internal_add_objects();
  public:
  const ::Protocol::ObjectInfo& objects(int index) const;
  ::Protocol::ObjectInfo* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      objects() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > objects_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DESPAWN) */ {
 public:
  inline S_DESPAWN() : S_DESPAWN(nullptr) {}
  ~S_DESPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DESPAWN(const S_DESPAWN& from);
  S_DESPAWN(S_DESPAWN&& from) noexcept
    : S_DESPAWN() {
    *this = ::std::move(from);
  }

  inline S_DESPAWN& operator=(const S_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DESPAWN& operator=(S_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const S_DESPAWN*>(
               &_S_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_DESPAWN& a, S_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DESPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DESPAWN& from) {
    S_DESPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DESPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DESPAWN";
  }
  protected:
  explicit S_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // repeated int32 objectIds = 1;
  int objectids_size() const;
  private:
  int _internal_objectids_size() const;
  public:
  void clear_objectids();
  private:
  int32_t _internal_objectids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_objectids() const;
  void _internal_add_objectids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_objectids();
  public:
  int32_t objectids(int index) const;
  void set_objectids(int index, int32_t value);
  void add_objectids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      objectids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_objectids();

  // @@protoc_insertion_point(class_scope:Protocol.S_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > objectids_;
    mutable std::atomic<int> _objectids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MOVE) */ {
 public:
  inline C_MOVE() : C_MOVE(nullptr) {}
  ~C_MOVE() override;
  explicit PROTOBUF_CONSTEXPR C_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MOVE(const C_MOVE& from);
  C_MOVE(C_MOVE&& from) noexcept
    : C_MOVE() {
    *this = ::std::move(from);
  }

  inline C_MOVE& operator=(const C_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MOVE& operator=(C_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MOVE* internal_default_instance() {
    return reinterpret_cast<const C_MOVE*>(
               &_C_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(C_MOVE& a, C_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MOVE& from) {
    C_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MOVE";
  }
  protected:
  explicit C_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 1,
    kTimeStampFieldNumber = 3,
  };
  // .Protocol.PositionInfo posInfo = 1;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PositionInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_posinfo();
  ::Protocol::PositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PositionInfo* posinfo);
  private:
  const ::Protocol::PositionInfo& _internal_posinfo() const;
  ::Protocol::PositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PositionInfo* posinfo);
  ::Protocol::PositionInfo* unsafe_arena_release_posinfo();

  // uint64 timeStamp = 3;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* posinfo_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MOVE) */ {
 public:
  inline S_MOVE() : S_MOVE(nullptr) {}
  ~S_MOVE() override;
  explicit PROTOBUF_CONSTEXPR S_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MOVE(const S_MOVE& from);
  S_MOVE(S_MOVE&& from) noexcept
    : S_MOVE() {
    *this = ::std::move(from);
  }

  inline S_MOVE& operator=(const S_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MOVE& operator=(S_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MOVE* internal_default_instance() {
    return reinterpret_cast<const S_MOVE*>(
               &_S_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_MOVE& a, S_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MOVE& from) {
    S_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MOVE";
  }
  protected:
  explicit S_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 2,
    kTimeStampFieldNumber = 3,
    kObjectIdFieldNumber = 1,
  };
  // .Protocol.PositionInfo posInfo = 2;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PositionInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_posinfo();
  ::Protocol::PositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PositionInfo* posinfo);
  private:
  const ::Protocol::PositionInfo& _internal_posinfo() const;
  ::Protocol::PositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PositionInfo* posinfo);
  ::Protocol::PositionInfo* unsafe_arena_release_posinfo();

  // uint64 timeStamp = 3;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // int32 objectId = 1;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* posinfo_;
    uint64_t timestamp_;
    int32_t objectid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_POS_SYNC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_POS_SYNC) */ {
 public:
  inline C_POS_SYNC() : C_POS_SYNC(nullptr) {}
  ~C_POS_SYNC() override;
  explicit PROTOBUF_CONSTEXPR C_POS_SYNC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_POS_SYNC(const C_POS_SYNC& from);
  C_POS_SYNC(C_POS_SYNC&& from) noexcept
    : C_POS_SYNC() {
    *this = ::std::move(from);
  }

  inline C_POS_SYNC& operator=(const C_POS_SYNC& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_POS_SYNC& operator=(C_POS_SYNC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_POS_SYNC& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_POS_SYNC* internal_default_instance() {
    return reinterpret_cast<const C_POS_SYNC*>(
               &_C_POS_SYNC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(C_POS_SYNC& a, C_POS_SYNC& b) {
    a.Swap(&b);
  }
  inline void Swap(C_POS_SYNC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_POS_SYNC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_POS_SYNC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_POS_SYNC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_POS_SYNC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_POS_SYNC& from) {
    C_POS_SYNC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_POS_SYNC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_POS_SYNC";
  }
  protected:
  explicit C_POS_SYNC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 1,
  };
  // .Protocol.PositionInfo posInfo = 1;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PositionInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_posinfo();
  ::Protocol::PositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PositionInfo* posinfo);
  private:
  const ::Protocol::PositionInfo& _internal_posinfo() const;
  ::Protocol::PositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PositionInfo* posinfo);
  ::Protocol::PositionInfo* unsafe_arena_release_posinfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_POS_SYNC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* posinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ATTACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ATTACK) */ {
 public:
  inline C_ATTACK() : C_ATTACK(nullptr) {}
  ~C_ATTACK() override;
  explicit PROTOBUF_CONSTEXPR C_ATTACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ATTACK(const C_ATTACK& from);
  C_ATTACK(C_ATTACK&& from) noexcept
    : C_ATTACK() {
    *this = ::std::move(from);
  }

  inline C_ATTACK& operator=(const C_ATTACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ATTACK& operator=(C_ATTACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ATTACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ATTACK* internal_default_instance() {
    return reinterpret_cast<const C_ATTACK*>(
               &_C_ATTACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(C_ATTACK& a, C_ATTACK& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ATTACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ATTACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ATTACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ATTACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ATTACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ATTACK& from) {
    C_ATTACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ATTACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ATTACK";
  }
  protected:
  explicit C_ATTACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirXFieldNumber = 1,
    kDirZFieldNumber = 2,
  };
  // float dirX = 1;
  void clear_dirx();
  float dirx() const;
  void set_dirx(float value);
  private:
  float _internal_dirx() const;
  void _internal_set_dirx(float value);
  public:

  // float dirZ = 2;
  void clear_dirz();
  float dirz() const;
  void set_dirz(float value);
  private:
  float _internal_dirz() const;
  void _internal_set_dirz(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ATTACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float dirx_;
    float dirz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ATTACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ATTACK) */ {
 public:
  inline S_ATTACK() : S_ATTACK(nullptr) {}
  ~S_ATTACK() override;
  explicit PROTOBUF_CONSTEXPR S_ATTACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ATTACK(const S_ATTACK& from);
  S_ATTACK(S_ATTACK&& from) noexcept
    : S_ATTACK() {
    *this = ::std::move(from);
  }

  inline S_ATTACK& operator=(const S_ATTACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ATTACK& operator=(S_ATTACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ATTACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ATTACK* internal_default_instance() {
    return reinterpret_cast<const S_ATTACK*>(
               &_S_ATTACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_ATTACK& a, S_ATTACK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ATTACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ATTACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ATTACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ATTACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ATTACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ATTACK& from) {
    S_ATTACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ATTACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ATTACK";
  }
  protected:
  explicit S_ATTACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackerIdFieldNumber = 1,
    kDirXFieldNumber = 2,
    kDirZFieldNumber = 3,
  };
  // int32 attackerId = 1;
  void clear_attackerid();
  int32_t attackerid() const;
  void set_attackerid(int32_t value);
  private:
  int32_t _internal_attackerid() const;
  void _internal_set_attackerid(int32_t value);
  public:

  // float dirX = 2;
  void clear_dirx();
  float dirx() const;
  void set_dirx(float value);
  private:
  float _internal_dirx() const;
  void _internal_set_dirx(float value);
  public:

  // float dirZ = 3;
  void clear_dirz();
  float dirz() const;
  void set_dirz(float value);
  private:
  float _internal_dirz() const;
  void _internal_set_dirz(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ATTACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t attackerid_;
    float dirx_;
    float dirz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_UPDATE_RESOURCE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_UPDATE_RESOURCE) */ {
 public:
  inline S_UPDATE_RESOURCE() : S_UPDATE_RESOURCE(nullptr) {}
  ~S_UPDATE_RESOURCE() override;
  explicit PROTOBUF_CONSTEXPR S_UPDATE_RESOURCE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UPDATE_RESOURCE(const S_UPDATE_RESOURCE& from);
  S_UPDATE_RESOURCE(S_UPDATE_RESOURCE&& from) noexcept
    : S_UPDATE_RESOURCE() {
    *this = ::std::move(from);
  }

  inline S_UPDATE_RESOURCE& operator=(const S_UPDATE_RESOURCE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UPDATE_RESOURCE& operator=(S_UPDATE_RESOURCE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UPDATE_RESOURCE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UPDATE_RESOURCE* internal_default_instance() {
    return reinterpret_cast<const S_UPDATE_RESOURCE*>(
               &_S_UPDATE_RESOURCE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(S_UPDATE_RESOURCE& a, S_UPDATE_RESOURCE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UPDATE_RESOURCE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UPDATE_RESOURCE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_UPDATE_RESOURCE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_UPDATE_RESOURCE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_UPDATE_RESOURCE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_UPDATE_RESOURCE& from) {
    S_UPDATE_RESOURCE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UPDATE_RESOURCE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_UPDATE_RESOURCE";
  }
  protected:
  explicit S_UPDATE_RESOURCE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kNowValueFieldNumber = 2,
    kChangeValueFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // int32 objectId = 1;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // int32 nowValue = 2;
  void clear_nowvalue();
  int32_t nowvalue() const;
  void set_nowvalue(int32_t value);
  private:
  int32_t _internal_nowvalue() const;
  void _internal_set_nowvalue(int32_t value);
  public:

  // int32 changeValue = 3;
  void clear_changevalue();
  int32_t changevalue() const;
  void set_changevalue(int32_t value);
  private:
  int32_t _internal_changevalue() const;
  void _internal_set_changevalue(int32_t value);
  public:

  // .Protocol.ResourceType type = 4;
  void clear_type();
  ::Protocol::ResourceType type() const;
  void set_type(::Protocol::ResourceType value);
  private:
  ::Protocol::ResourceType _internal_type() const;
  void _internal_set_type(::Protocol::ResourceType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_UPDATE_RESOURCE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t objectid_;
    int32_t nowvalue_;
    int32_t changevalue_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DIE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DIE) */ {
 public:
  inline S_DIE() : S_DIE(nullptr) {}
  ~S_DIE() override;
  explicit PROTOBUF_CONSTEXPR S_DIE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DIE(const S_DIE& from);
  S_DIE(S_DIE&& from) noexcept
    : S_DIE() {
    *this = ::std::move(from);
  }

  inline S_DIE& operator=(const S_DIE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DIE& operator=(S_DIE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DIE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DIE* internal_default_instance() {
    return reinterpret_cast<const S_DIE*>(
               &_S_DIE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_DIE& a, S_DIE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DIE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DIE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DIE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DIE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DIE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DIE& from) {
    S_DIE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DIE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DIE";
  }
  protected:
  explicit S_DIE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAttackerIdFieldNumber = 2,
  };
  // int32 objectId = 1;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // int32 attackerId = 2;
  void clear_attackerid();
  int32_t attackerid() const;
  void set_attackerid(int32_t value);
  private:
  int32_t _internal_attackerid() const;
  void _internal_set_attackerid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_DIE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t objectid_;
    int32_t attackerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PING final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PING) */ {
 public:
  inline S_PING() : S_PING(nullptr) {}
  ~S_PING() override;
  explicit PROTOBUF_CONSTEXPR S_PING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PING(const S_PING& from);
  S_PING(S_PING&& from) noexcept
    : S_PING() {
    *this = ::std::move(from);
  }

  inline S_PING& operator=(const S_PING& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PING& operator=(S_PING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PING& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PING* internal_default_instance() {
    return reinterpret_cast<const S_PING*>(
               &_S_PING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_PING& a, S_PING& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PING& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PING& from) {
    S_PING::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PING* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PING";
  }
  protected:
  explicit S_PING(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeStampFieldNumber = 1,
  };
  // uint64 timeStamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PONG final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PONG) */ {
 public:
  inline C_PONG() : C_PONG(nullptr) {}
  ~C_PONG() override;
  explicit PROTOBUF_CONSTEXPR C_PONG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PONG(const C_PONG& from);
  C_PONG(C_PONG&& from) noexcept
    : C_PONG() {
    *this = ::std::move(from);
  }

  inline C_PONG& operator=(const C_PONG& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PONG& operator=(C_PONG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PONG& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PONG* internal_default_instance() {
    return reinterpret_cast<const C_PONG*>(
               &_C_PONG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(C_PONG& a, C_PONG& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PONG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PONG* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PONG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PONG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PONG& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PONG& from) {
    C_PONG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PONG* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PONG";
  }
  protected:
  explicit C_PONG(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeStampFieldNumber = 1,
  };
  // uint64 timeStamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PONG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_USER_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_USER_STATUS) */ {
 public:
  inline S_USER_STATUS() : S_USER_STATUS(nullptr) {}
  ~S_USER_STATUS() override;
  explicit PROTOBUF_CONSTEXPR S_USER_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_USER_STATUS(const S_USER_STATUS& from);
  S_USER_STATUS(S_USER_STATUS&& from) noexcept
    : S_USER_STATUS() {
    *this = ::std::move(from);
  }

  inline S_USER_STATUS& operator=(const S_USER_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_USER_STATUS& operator=(S_USER_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_USER_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_USER_STATUS* internal_default_instance() {
    return reinterpret_cast<const S_USER_STATUS*>(
               &_S_USER_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(S_USER_STATUS& a, S_USER_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(S_USER_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_USER_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_USER_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_USER_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_USER_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_USER_STATUS& from) {
    S_USER_STATUS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_USER_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_USER_STATUS";
  }
  protected:
  explicit S_USER_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerDataFieldNumber = 1,
  };
  // .Protocol.PlayerInfo playerData = 1;
  bool has_playerdata() const;
  private:
  bool _internal_has_playerdata() const;
  public:
  void clear_playerdata();
  const ::Protocol::PlayerInfo& playerdata() const;
  PROTOBUF_NODISCARD ::Protocol::PlayerInfo* release_playerdata();
  ::Protocol::PlayerInfo* mutable_playerdata();
  void set_allocated_playerdata(::Protocol::PlayerInfo* playerdata);
  private:
  const ::Protocol::PlayerInfo& _internal_playerdata() const;
  ::Protocol::PlayerInfo* _internal_mutable_playerdata();
  public:
  void unsafe_arena_set_allocated_playerdata(
      ::Protocol::PlayerInfo* playerdata);
  ::Protocol::PlayerInfo* unsafe_arena_release_playerdata();

  // @@protoc_insertion_point(class_scope:Protocol.S_USER_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PlayerInfo* playerdata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ITEM_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ITEM_LIST) */ {
 public:
  inline S_ITEM_LIST() : S_ITEM_LIST(nullptr) {}
  ~S_ITEM_LIST() override;
  explicit PROTOBUF_CONSTEXPR S_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ITEM_LIST(const S_ITEM_LIST& from);
  S_ITEM_LIST(S_ITEM_LIST&& from) noexcept
    : S_ITEM_LIST() {
    *this = ::std::move(from);
  }

  inline S_ITEM_LIST& operator=(const S_ITEM_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ITEM_LIST& operator=(S_ITEM_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ITEM_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ITEM_LIST* internal_default_instance() {
    return reinterpret_cast<const S_ITEM_LIST*>(
               &_S_ITEM_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_ITEM_LIST& a, S_ITEM_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ITEM_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ITEM_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ITEM_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ITEM_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ITEM_LIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ITEM_LIST& from) {
    S_ITEM_LIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ITEM_LIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ITEM_LIST";
  }
  protected:
  explicit S_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ItemInfo& _internal_items(int index) const;
  ::Protocol::ItemInfo* _internal_add_items();
  public:
  const ::Protocol::ItemInfo& items(int index) const;
  ::Protocol::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_ITEM_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ADD_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ADD_ITEM) */ {
 public:
  inline S_ADD_ITEM() : S_ADD_ITEM(nullptr) {}
  ~S_ADD_ITEM() override;
  explicit PROTOBUF_CONSTEXPR S_ADD_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ADD_ITEM(const S_ADD_ITEM& from);
  S_ADD_ITEM(S_ADD_ITEM&& from) noexcept
    : S_ADD_ITEM() {
    *this = ::std::move(from);
  }

  inline S_ADD_ITEM& operator=(const S_ADD_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ADD_ITEM& operator=(S_ADD_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ADD_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ADD_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_ADD_ITEM*>(
               &_S_ADD_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(S_ADD_ITEM& a, S_ADD_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ADD_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ADD_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ADD_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ADD_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ADD_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ADD_ITEM& from) {
    S_ADD_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ADD_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ADD_ITEM";
  }
  protected:
  explicit S_ADD_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ItemInfo& _internal_items(int index) const;
  ::Protocol::ItemInfo* _internal_add_items();
  public:
  const ::Protocol::ItemInfo& items(int index) const;
  ::Protocol::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_ADD_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHANGE_CURRENCY final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHANGE_CURRENCY) */ {
 public:
  inline S_CHANGE_CURRENCY() : S_CHANGE_CURRENCY(nullptr) {}
  ~S_CHANGE_CURRENCY() override;
  explicit PROTOBUF_CONSTEXPR S_CHANGE_CURRENCY(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHANGE_CURRENCY(const S_CHANGE_CURRENCY& from);
  S_CHANGE_CURRENCY(S_CHANGE_CURRENCY&& from) noexcept
    : S_CHANGE_CURRENCY() {
    *this = ::std::move(from);
  }

  inline S_CHANGE_CURRENCY& operator=(const S_CHANGE_CURRENCY& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHANGE_CURRENCY& operator=(S_CHANGE_CURRENCY&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHANGE_CURRENCY& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHANGE_CURRENCY* internal_default_instance() {
    return reinterpret_cast<const S_CHANGE_CURRENCY*>(
               &_S_CHANGE_CURRENCY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_CHANGE_CURRENCY& a, S_CHANGE_CURRENCY& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHANGE_CURRENCY* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHANGE_CURRENCY* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHANGE_CURRENCY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHANGE_CURRENCY>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHANGE_CURRENCY& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHANGE_CURRENCY& from) {
    S_CHANGE_CURRENCY::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHANGE_CURRENCY* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHANGE_CURRENCY";
  }
  protected:
  explicit S_CHANGE_CURRENCY(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyTypeFieldNumber = 1,
    kChangeAmountFieldNumber = 2,
    kTotalAmountFieldNumber = 3,
  };
  // .Protocol.CurrencyType currencyType = 1;
  void clear_currencytype();
  ::Protocol::CurrencyType currencytype() const;
  void set_currencytype(::Protocol::CurrencyType value);
  private:
  ::Protocol::CurrencyType _internal_currencytype() const;
  void _internal_set_currencytype(::Protocol::CurrencyType value);
  public:

  // int32 changeAmount = 2;
  void clear_changeamount();
  int32_t changeamount() const;
  void set_changeamount(int32_t value);
  private:
  int32_t _internal_changeamount() const;
  void _internal_set_changeamount(int32_t value);
  public:

  // int32 totalAmount = 3;
  void clear_totalamount();
  int32_t totalamount() const;
  void set_totalamount(int32_t value);
  private:
  int32_t _internal_totalamount() const;
  void _internal_set_totalamount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHANGE_CURRENCY)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int currencytype_;
    int32_t changeamount_;
    int32_t totalamount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SKILL) */ {
 public:
  inline C_SKILL() : C_SKILL(nullptr) {}
  ~C_SKILL() override;
  explicit PROTOBUF_CONSTEXPR C_SKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SKILL(const C_SKILL& from);
  C_SKILL(C_SKILL&& from) noexcept
    : C_SKILL() {
    *this = ::std::move(from);
  }

  inline C_SKILL& operator=(const C_SKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SKILL& operator=(C_SKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SKILL* internal_default_instance() {
    return reinterpret_cast<const C_SKILL*>(
               &_C_SKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(C_SKILL& a, C_SKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_SKILL& from) {
    C_SKILL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SKILL";
  }
  protected:
  explicit C_SKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 1,
    kSkillTemplateIdFieldNumber = 2,
  };
  // .Protocol.PositionInfo posInfo = 1;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PositionInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_posinfo();
  ::Protocol::PositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PositionInfo* posinfo);
  private:
  const ::Protocol::PositionInfo& _internal_posinfo() const;
  ::Protocol::PositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PositionInfo* posinfo);
  ::Protocol::PositionInfo* unsafe_arena_release_posinfo();

  // int32 skillTemplateId = 2;
  void clear_skilltemplateid();
  int32_t skilltemplateid() const;
  void set_skilltemplateid(int32_t value);
  private:
  int32_t _internal_skilltemplateid() const;
  void _internal_set_skilltemplateid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* posinfo_;
    int32_t skilltemplateid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SKILL) */ {
 public:
  inline S_SKILL() : S_SKILL(nullptr) {}
  ~S_SKILL() override;
  explicit PROTOBUF_CONSTEXPR S_SKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SKILL(const S_SKILL& from);
  S_SKILL(S_SKILL&& from) noexcept
    : S_SKILL() {
    *this = ::std::move(from);
  }

  inline S_SKILL& operator=(const S_SKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SKILL& operator=(S_SKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SKILL* internal_default_instance() {
    return reinterpret_cast<const S_SKILL*>(
               &_S_SKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(S_SKILL& a, S_SKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SKILL& from) {
    S_SKILL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SKILL";
  }
  protected:
  explicit S_SKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosInfoFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kSkillTemplateIdFieldNumber = 3,
    kAttackerIdFieldNumber = 4,
  };
  // .Protocol.PositionInfo posInfo = 2;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PositionInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_posinfo();
  ::Protocol::PositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PositionInfo* posinfo);
  private:
  const ::Protocol::PositionInfo& _internal_posinfo() const;
  ::Protocol::PositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PositionInfo* posinfo);
  ::Protocol::PositionInfo* unsafe_arena_release_posinfo();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 skillTemplateId = 3;
  void clear_skilltemplateid();
  int32_t skilltemplateid() const;
  void set_skilltemplateid(int32_t value);
  private:
  int32_t _internal_skilltemplateid() const;
  void _internal_set_skilltemplateid(int32_t value);
  public:

  // int32 attackerId = 4;
  void clear_attackerid();
  int32_t attackerid() const;
  void set_attackerid(int32_t value);
  private:
  int32_t _internal_attackerid() const;
  void _internal_set_attackerid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* posinfo_;
    bool success_;
    int32_t skilltemplateid_;
    int32_t attackerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_USE_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_USE_ITEM) */ {
 public:
  inline C_USE_ITEM() : C_USE_ITEM(nullptr) {}
  ~C_USE_ITEM() override;
  explicit PROTOBUF_CONSTEXPR C_USE_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_USE_ITEM(const C_USE_ITEM& from);
  C_USE_ITEM(C_USE_ITEM&& from) noexcept
    : C_USE_ITEM() {
    *this = ::std::move(from);
  }

  inline C_USE_ITEM& operator=(const C_USE_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_USE_ITEM& operator=(C_USE_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_USE_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_USE_ITEM* internal_default_instance() {
    return reinterpret_cast<const C_USE_ITEM*>(
               &_C_USE_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(C_USE_ITEM& a, C_USE_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_USE_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_USE_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_USE_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_USE_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_USE_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_USE_ITEM& from) {
    C_USE_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_USE_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_USE_ITEM";
  }
  protected:
  explicit C_USE_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemDbIdFieldNumber = 1,
  };
  // int32 itemDbId = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_USE_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t itemdbid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHANGE_ITEM_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHANGE_ITEM_INFO) */ {
 public:
  inline S_CHANGE_ITEM_INFO() : S_CHANGE_ITEM_INFO(nullptr) {}
  ~S_CHANGE_ITEM_INFO() override;
  explicit PROTOBUF_CONSTEXPR S_CHANGE_ITEM_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHANGE_ITEM_INFO(const S_CHANGE_ITEM_INFO& from);
  S_CHANGE_ITEM_INFO(S_CHANGE_ITEM_INFO&& from) noexcept
    : S_CHANGE_ITEM_INFO() {
    *this = ::std::move(from);
  }

  inline S_CHANGE_ITEM_INFO& operator=(const S_CHANGE_ITEM_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHANGE_ITEM_INFO& operator=(S_CHANGE_ITEM_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHANGE_ITEM_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHANGE_ITEM_INFO* internal_default_instance() {
    return reinterpret_cast<const S_CHANGE_ITEM_INFO*>(
               &_S_CHANGE_ITEM_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(S_CHANGE_ITEM_INFO& a, S_CHANGE_ITEM_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHANGE_ITEM_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHANGE_ITEM_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHANGE_ITEM_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHANGE_ITEM_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHANGE_ITEM_INFO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHANGE_ITEM_INFO& from) {
    S_CHANGE_ITEM_INFO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHANGE_ITEM_INFO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHANGE_ITEM_INFO";
  }
  protected:
  explicit S_CHANGE_ITEM_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_items();
  private:
  const ::Protocol::ItemInfo& _internal_items(int index) const;
  ::Protocol::ItemInfo* _internal_add_items();
  public:
  const ::Protocol::ItemInfo& items(int index) const;
  ::Protocol::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_CHANGE_ITEM_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_DROP_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_DROP_ITEM) */ {
 public:
  inline C_DROP_ITEM() : C_DROP_ITEM(nullptr) {}
  ~C_DROP_ITEM() override;
  explicit PROTOBUF_CONSTEXPR C_DROP_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_DROP_ITEM(const C_DROP_ITEM& from);
  C_DROP_ITEM(C_DROP_ITEM&& from) noexcept
    : C_DROP_ITEM() {
    *this = ::std::move(from);
  }

  inline C_DROP_ITEM& operator=(const C_DROP_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_DROP_ITEM& operator=(C_DROP_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_DROP_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_DROP_ITEM* internal_default_instance() {
    return reinterpret_cast<const C_DROP_ITEM*>(
               &_C_DROP_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(C_DROP_ITEM& a, C_DROP_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_DROP_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_DROP_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_DROP_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_DROP_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_DROP_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_DROP_ITEM& from) {
    C_DROP_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_DROP_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_DROP_ITEM";
  }
  protected:
  explicit C_DROP_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemDbIdFieldNumber = 1,
  };
  // int32 itemDbId = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_DROP_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t itemdbid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_REMOVE_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_REMOVE_ITEM) */ {
 public:
  inline S_REMOVE_ITEM() : S_REMOVE_ITEM(nullptr) {}
  ~S_REMOVE_ITEM() override;
  explicit PROTOBUF_CONSTEXPR S_REMOVE_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_REMOVE_ITEM(const S_REMOVE_ITEM& from);
  S_REMOVE_ITEM(S_REMOVE_ITEM&& from) noexcept
    : S_REMOVE_ITEM() {
    *this = ::std::move(from);
  }

  inline S_REMOVE_ITEM& operator=(const S_REMOVE_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_REMOVE_ITEM& operator=(S_REMOVE_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_REMOVE_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_REMOVE_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_REMOVE_ITEM*>(
               &_S_REMOVE_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(S_REMOVE_ITEM& a, S_REMOVE_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_REMOVE_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_REMOVE_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_REMOVE_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_REMOVE_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_REMOVE_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_REMOVE_ITEM& from) {
    S_REMOVE_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_REMOVE_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_REMOVE_ITEM";
  }
  protected:
  explicit S_REMOVE_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemovedItemDbIDFieldNumber = 1,
  };
  // int32 removedItemDbID = 1;
  void clear_removeditemdbid();
  int32_t removeditemdbid() const;
  void set_removeditemdbid(int32_t value);
  private:
  int32_t _internal_removeditemdbid() const;
  void _internal_set_removeditemdbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_REMOVE_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t removeditemdbid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_REQUEST_MARKET_ITEM_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_REQUEST_MARKET_ITEM_LIST) */ {
 public:
  inline C_REQUEST_MARKET_ITEM_LIST() : C_REQUEST_MARKET_ITEM_LIST(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_REQUEST_MARKET_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_REQUEST_MARKET_ITEM_LIST(const C_REQUEST_MARKET_ITEM_LIST& from);
  C_REQUEST_MARKET_ITEM_LIST(C_REQUEST_MARKET_ITEM_LIST&& from) noexcept
    : C_REQUEST_MARKET_ITEM_LIST() {
    *this = ::std::move(from);
  }

  inline C_REQUEST_MARKET_ITEM_LIST& operator=(const C_REQUEST_MARKET_ITEM_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_REQUEST_MARKET_ITEM_LIST& operator=(C_REQUEST_MARKET_ITEM_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_REQUEST_MARKET_ITEM_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_REQUEST_MARKET_ITEM_LIST* internal_default_instance() {
    return reinterpret_cast<const C_REQUEST_MARKET_ITEM_LIST*>(
               &_C_REQUEST_MARKET_ITEM_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(C_REQUEST_MARKET_ITEM_LIST& a, C_REQUEST_MARKET_ITEM_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_REQUEST_MARKET_ITEM_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_REQUEST_MARKET_ITEM_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_REQUEST_MARKET_ITEM_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_REQUEST_MARKET_ITEM_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_REQUEST_MARKET_ITEM_LIST& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_REQUEST_MARKET_ITEM_LIST& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_REQUEST_MARKET_ITEM_LIST";
  }
  protected:
  explicit C_REQUEST_MARKET_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_REQUEST_MARKET_ITEM_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MARKET_ITEM_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MARKET_ITEM_LIST) */ {
 public:
  inline S_MARKET_ITEM_LIST() : S_MARKET_ITEM_LIST(nullptr) {}
  ~S_MARKET_ITEM_LIST() override;
  explicit PROTOBUF_CONSTEXPR S_MARKET_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MARKET_ITEM_LIST(const S_MARKET_ITEM_LIST& from);
  S_MARKET_ITEM_LIST(S_MARKET_ITEM_LIST&& from) noexcept
    : S_MARKET_ITEM_LIST() {
    *this = ::std::move(from);
  }

  inline S_MARKET_ITEM_LIST& operator=(const S_MARKET_ITEM_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MARKET_ITEM_LIST& operator=(S_MARKET_ITEM_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MARKET_ITEM_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MARKET_ITEM_LIST* internal_default_instance() {
    return reinterpret_cast<const S_MARKET_ITEM_LIST*>(
               &_S_MARKET_ITEM_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(S_MARKET_ITEM_LIST& a, S_MARKET_ITEM_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MARKET_ITEM_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MARKET_ITEM_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MARKET_ITEM_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MARKET_ITEM_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MARKET_ITEM_LIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MARKET_ITEM_LIST& from) {
    S_MARKET_ITEM_LIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MARKET_ITEM_LIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MARKET_ITEM_LIST";
  }
  protected:
  explicit S_MARKET_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .Protocol.MarketItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::Protocol::MarketItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MarketItemInfo >*
      mutable_items();
  private:
  const ::Protocol::MarketItemInfo& _internal_items(int index) const;
  ::Protocol::MarketItemInfo* _internal_add_items();
  public:
  const ::Protocol::MarketItemInfo& items(int index) const;
  ::Protocol::MarketItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MarketItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_MARKET_ITEM_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MarketItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PURCHASE_MARKET_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PURCHASE_MARKET_ITEM) */ {
 public:
  inline C_PURCHASE_MARKET_ITEM() : C_PURCHASE_MARKET_ITEM(nullptr) {}
  ~C_PURCHASE_MARKET_ITEM() override;
  explicit PROTOBUF_CONSTEXPR C_PURCHASE_MARKET_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PURCHASE_MARKET_ITEM(const C_PURCHASE_MARKET_ITEM& from);
  C_PURCHASE_MARKET_ITEM(C_PURCHASE_MARKET_ITEM&& from) noexcept
    : C_PURCHASE_MARKET_ITEM() {
    *this = ::std::move(from);
  }

  inline C_PURCHASE_MARKET_ITEM& operator=(const C_PURCHASE_MARKET_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PURCHASE_MARKET_ITEM& operator=(C_PURCHASE_MARKET_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PURCHASE_MARKET_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PURCHASE_MARKET_ITEM* internal_default_instance() {
    return reinterpret_cast<const C_PURCHASE_MARKET_ITEM*>(
               &_C_PURCHASE_MARKET_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(C_PURCHASE_MARKET_ITEM& a, C_PURCHASE_MARKET_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PURCHASE_MARKET_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PURCHASE_MARKET_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PURCHASE_MARKET_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PURCHASE_MARKET_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PURCHASE_MARKET_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PURCHASE_MARKET_ITEM& from) {
    C_PURCHASE_MARKET_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PURCHASE_MARKET_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PURCHASE_MARKET_ITEM";
  }
  protected:
  explicit C_PURCHASE_MARKET_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemdDbIdFieldNumber = 1,
  };
  // int32 itemdDbId = 1;
  void clear_itemddbid();
  int32_t itemddbid() const;
  void set_itemddbid(int32_t value);
  private:
  int32_t _internal_itemddbid() const;
  void _internal_set_itemddbid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PURCHASE_MARKET_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t itemddbid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_REGISTER_MARKET_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_REGISTER_MARKET_ITEM) */ {
 public:
  inline C_REGISTER_MARKET_ITEM() : C_REGISTER_MARKET_ITEM(nullptr) {}
  ~C_REGISTER_MARKET_ITEM() override;
  explicit PROTOBUF_CONSTEXPR C_REGISTER_MARKET_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_REGISTER_MARKET_ITEM(const C_REGISTER_MARKET_ITEM& from);
  C_REGISTER_MARKET_ITEM(C_REGISTER_MARKET_ITEM&& from) noexcept
    : C_REGISTER_MARKET_ITEM() {
    *this = ::std::move(from);
  }

  inline C_REGISTER_MARKET_ITEM& operator=(const C_REGISTER_MARKET_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_REGISTER_MARKET_ITEM& operator=(C_REGISTER_MARKET_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_REGISTER_MARKET_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_REGISTER_MARKET_ITEM* internal_default_instance() {
    return reinterpret_cast<const C_REGISTER_MARKET_ITEM*>(
               &_C_REGISTER_MARKET_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(C_REGISTER_MARKET_ITEM& a, C_REGISTER_MARKET_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_REGISTER_MARKET_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_REGISTER_MARKET_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_REGISTER_MARKET_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_REGISTER_MARKET_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_REGISTER_MARKET_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_REGISTER_MARKET_ITEM& from) {
    C_REGISTER_MARKET_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_REGISTER_MARKET_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_REGISTER_MARKET_ITEM";
  }
  protected:
  explicit C_REGISTER_MARKET_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemdDbIdFieldNumber = 1,
    kCostFieldNumber = 2,
  };
  // int32 itemdDbId = 1;
  void clear_itemddbid();
  int32_t itemddbid() const;
  void set_itemddbid(int32_t value);
  private:
  int32_t _internal_itemddbid() const;
  void _internal_set_itemddbid(int32_t value);
  public:

  // int32 cost = 2;
  void clear_cost();
  int32_t cost() const;
  void set_cost(int32_t value);
  private:
  int32_t _internal_cost() const;
  void _internal_set_cost(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_REGISTER_MARKET_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t itemddbid_;
    int32_t cost_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PURCHASE_MARKET_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PURCHASE_MARKET_ITEM) */ {
 public:
  inline S_PURCHASE_MARKET_ITEM() : S_PURCHASE_MARKET_ITEM(nullptr) {}
  ~S_PURCHASE_MARKET_ITEM() override;
  explicit PROTOBUF_CONSTEXPR S_PURCHASE_MARKET_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PURCHASE_MARKET_ITEM(const S_PURCHASE_MARKET_ITEM& from);
  S_PURCHASE_MARKET_ITEM(S_PURCHASE_MARKET_ITEM&& from) noexcept
    : S_PURCHASE_MARKET_ITEM() {
    *this = ::std::move(from);
  }

  inline S_PURCHASE_MARKET_ITEM& operator=(const S_PURCHASE_MARKET_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PURCHASE_MARKET_ITEM& operator=(S_PURCHASE_MARKET_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PURCHASE_MARKET_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PURCHASE_MARKET_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_PURCHASE_MARKET_ITEM*>(
               &_S_PURCHASE_MARKET_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(S_PURCHASE_MARKET_ITEM& a, S_PURCHASE_MARKET_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PURCHASE_MARKET_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PURCHASE_MARKET_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PURCHASE_MARKET_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PURCHASE_MARKET_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PURCHASE_MARKET_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PURCHASE_MARKET_ITEM& from) {
    S_PURCHASE_MARKET_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PURCHASE_MARKET_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PURCHASE_MARKET_ITEM";
  }
  protected:
  explicit S_PURCHASE_MARKET_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .Protocol.ItemInfo items = 2;
  bool has_items() const;
  private:
  bool _internal_has_items() const;
  public:
  void clear_items();
  const ::Protocol::ItemInfo& items() const;
  PROTOBUF_NODISCARD ::Protocol::ItemInfo* release_items();
  ::Protocol::ItemInfo* mutable_items();
  void set_allocated_items(::Protocol::ItemInfo* items);
  private:
  const ::Protocol::ItemInfo& _internal_items() const;
  ::Protocol::ItemInfo* _internal_mutable_items();
  public:
  void unsafe_arena_set_allocated_items(
      ::Protocol::ItemInfo* items);
  ::Protocol::ItemInfo* unsafe_arena_release_items();

  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PURCHASE_MARKET_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ItemInfo* items_;
    bool result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CHAT) */ {
 public:
  inline C_CHAT() : C_CHAT(nullptr) {}
  ~C_CHAT() override;
  explicit PROTOBUF_CONSTEXPR C_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHAT(const C_CHAT& from);
  C_CHAT(C_CHAT&& from) noexcept
    : C_CHAT() {
    *this = ::std::move(from);
  }

  inline C_CHAT& operator=(const C_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHAT& operator=(C_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHAT* internal_default_instance() {
    return reinterpret_cast<const C_CHAT*>(
               &_C_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(C_CHAT& a, C_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CHAT& from) {
    C_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CHAT";
  }
  protected:
  explicit C_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kSenderIdFieldNumber = 2,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 senderId = 2;
  void clear_senderid();
  int32_t senderid() const;
  void set_senderid(int32_t value);
  private:
  int32_t _internal_senderid() const;
  void _internal_set_senderid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t senderid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHAT) */ {
 public:
  inline S_CHAT() : S_CHAT(nullptr) {}
  ~S_CHAT() override;
  explicit PROTOBUF_CONSTEXPR S_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHAT(const S_CHAT& from);
  S_CHAT(S_CHAT&& from) noexcept
    : S_CHAT() {
    *this = ::std::move(from);
  }

  inline S_CHAT& operator=(const S_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHAT& operator=(S_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHAT* internal_default_instance() {
    return reinterpret_cast<const S_CHAT*>(
               &_S_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(S_CHAT& a, S_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHAT& from) {
    S_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHAT";
  }
  protected:
  explicit S_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixFieldNumber = 1,
    kContentFieldNumber = 2,
    kTypeFieldNumber = 3,
    kSenderIdFieldNumber = 4,
  };
  // string prefix = 1;
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .Protocol.ChatType type = 3;
  void clear_type();
  ::Protocol::ChatType type() const;
  void set_type(::Protocol::ChatType value);
  private:
  ::Protocol::ChatType _internal_type() const;
  void _internal_set_type(::Protocol::ChatType value);
  public:

  // int32 senderId = 4;
  void clear_senderid();
  int32_t senderid() const;
  void set_senderid(int32_t value);
  private:
  int32_t _internal_senderid() const;
  void _internal_set_senderid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int type_;
    int32_t senderid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_WHISPER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_WHISPER) */ {
 public:
  inline C_WHISPER() : C_WHISPER(nullptr) {}
  ~C_WHISPER() override;
  explicit PROTOBUF_CONSTEXPR C_WHISPER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_WHISPER(const C_WHISPER& from);
  C_WHISPER(C_WHISPER&& from) noexcept
    : C_WHISPER() {
    *this = ::std::move(from);
  }

  inline C_WHISPER& operator=(const C_WHISPER& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_WHISPER& operator=(C_WHISPER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_WHISPER& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_WHISPER* internal_default_instance() {
    return reinterpret_cast<const C_WHISPER*>(
               &_C_WHISPER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(C_WHISPER& a, C_WHISPER& b) {
    a.Swap(&b);
  }
  inline void Swap(C_WHISPER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_WHISPER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_WHISPER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_WHISPER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_WHISPER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_WHISPER& from) {
    C_WHISPER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_WHISPER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_WHISPER";
  }
  protected:
  explicit C_WHISPER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiverNameFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string receiverName = 1;
  void clear_receivername();
  const std::string& receivername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receivername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receivername();
  PROTOBUF_NODISCARD std::string* release_receivername();
  void set_allocated_receivername(std::string* receivername);
  private:
  const std::string& _internal_receivername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receivername(const std::string& value);
  std::string* _internal_mutable_receivername();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_WHISPER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receivername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_LOGIN

// string id = 1;
inline void C_LOGIN::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& C_LOGIN::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.id)
}
inline std::string* C_LOGIN::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LOGIN.id)
  return _s;
}
inline const std::string& C_LOGIN::_internal_id() const {
  return _impl_.id_.Get();
}
inline void C_LOGIN::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_id() {
  // @@protoc_insertion_point(field_release:Protocol.C_LOGIN.id)
  return _impl_.id_.Release();
}
inline void C_LOGIN::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LOGIN.id)
}

// string password = 2;
inline void C_LOGIN::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& C_LOGIN::password() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.password)
}
inline std::string* C_LOGIN::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LOGIN.password)
  return _s;
}
inline const std::string& C_LOGIN::_internal_password() const {
  return _impl_.password_.Get();
}
inline void C_LOGIN::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.C_LOGIN.password)
  return _impl_.password_.Release();
}
inline void C_LOGIN::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LOGIN.password)
}

// -------------------------------------------------------------------

// C_SIGN_UP

// string id = 1;
inline void C_SIGN_UP::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& C_SIGN_UP::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SIGN_UP.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_SIGN_UP::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_SIGN_UP.id)
}
inline std::string* C_SIGN_UP::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Protocol.C_SIGN_UP.id)
  return _s;
}
inline const std::string& C_SIGN_UP::_internal_id() const {
  return _impl_.id_.Get();
}
inline void C_SIGN_UP::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* C_SIGN_UP::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* C_SIGN_UP::release_id() {
  // @@protoc_insertion_point(field_release:Protocol.C_SIGN_UP.id)
  return _impl_.id_.Release();
}
inline void C_SIGN_UP::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_SIGN_UP.id)
}

// string password = 2;
inline void C_SIGN_UP::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& C_SIGN_UP::password() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SIGN_UP.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_SIGN_UP::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_SIGN_UP.password)
}
inline std::string* C_SIGN_UP::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Protocol.C_SIGN_UP.password)
  return _s;
}
inline const std::string& C_SIGN_UP::_internal_password() const {
  return _impl_.password_.Get();
}
inline void C_SIGN_UP::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* C_SIGN_UP::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* C_SIGN_UP::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.C_SIGN_UP.password)
  return _impl_.password_.Release();
}
inline void C_SIGN_UP::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_SIGN_UP.password)
}

// -------------------------------------------------------------------

// S_LOGIN

// bool success = 1;
inline void S_LOGIN::clear_success() {
  _impl_.success_ = false;
}
inline bool S_LOGIN::_internal_success() const {
  return _impl_.success_;
}
inline bool S_LOGIN::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.success)
  return _internal_success();
}
inline void S_LOGIN::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_LOGIN::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOGIN.success)
}

// .Protocol.PlayerInfo playerInfo = 2;
inline bool S_LOGIN::_internal_has_playerinfo() const {
  return this != internal_default_instance() && _impl_.playerinfo_ != nullptr;
}
inline bool S_LOGIN::has_playerinfo() const {
  return _internal_has_playerinfo();
}
inline const ::Protocol::PlayerInfo& S_LOGIN::_internal_playerinfo() const {
  const ::Protocol::PlayerInfo* p = _impl_.playerinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PlayerInfo&>(
      ::Protocol::_PlayerInfo_default_instance_);
}
inline const ::Protocol::PlayerInfo& S_LOGIN::playerinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.playerInfo)
  return _internal_playerinfo();
}
inline void S_LOGIN::unsafe_arena_set_allocated_playerinfo(
    ::Protocol::PlayerInfo* playerinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playerinfo_);
  }
  _impl_.playerinfo_ = playerinfo;
  if (playerinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_LOGIN.playerInfo)
}
inline ::Protocol::PlayerInfo* S_LOGIN::release_playerinfo() {
  
  ::Protocol::PlayerInfo* temp = _impl_.playerinfo_;
  _impl_.playerinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PlayerInfo* S_LOGIN::unsafe_arena_release_playerinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_LOGIN.playerInfo)
  
  ::Protocol::PlayerInfo* temp = _impl_.playerinfo_;
  _impl_.playerinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PlayerInfo* S_LOGIN::_internal_mutable_playerinfo() {
  
  if (_impl_.playerinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PlayerInfo>(GetArenaForAllocation());
    _impl_.playerinfo_ = p;
  }
  return _impl_.playerinfo_;
}
inline ::Protocol::PlayerInfo* S_LOGIN::mutable_playerinfo() {
  ::Protocol::PlayerInfo* _msg = _internal_mutable_playerinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_LOGIN.playerInfo)
  return _msg;
}
inline void S_LOGIN::set_allocated_playerinfo(::Protocol::PlayerInfo* playerinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playerinfo_);
  }
  if (playerinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerinfo));
    if (message_arena != submessage_arena) {
      playerinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.playerinfo_ = playerinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_LOGIN.playerInfo)
}

// -------------------------------------------------------------------

// C_ENTER_GAME

// bool isDummy = 1;
inline void C_ENTER_GAME::clear_isdummy() {
  _impl_.isdummy_ = false;
}
inline bool C_ENTER_GAME::_internal_isdummy() const {
  return _impl_.isdummy_;
}
inline bool C_ENTER_GAME::isdummy() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_GAME.isDummy)
  return _internal_isdummy();
}
inline void C_ENTER_GAME::_internal_set_isdummy(bool value) {
  
  _impl_.isdummy_ = value;
}
inline void C_ENTER_GAME::set_isdummy(bool value) {
  _internal_set_isdummy(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER_GAME.isDummy)
}

// int32 dummyNumber = 2;
inline void C_ENTER_GAME::clear_dummynumber() {
  _impl_.dummynumber_ = 0;
}
inline int32_t C_ENTER_GAME::_internal_dummynumber() const {
  return _impl_.dummynumber_;
}
inline int32_t C_ENTER_GAME::dummynumber() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_GAME.dummyNumber)
  return _internal_dummynumber();
}
inline void C_ENTER_GAME::_internal_set_dummynumber(int32_t value) {
  
  _impl_.dummynumber_ = value;
}
inline void C_ENTER_GAME::set_dummynumber(int32_t value) {
  _internal_set_dummynumber(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER_GAME.dummyNumber)
}

// .Protocol.ObjectInfo objectInfo = 3;
inline bool C_ENTER_GAME::_internal_has_objectinfo() const {
  return this != internal_default_instance() && _impl_.objectinfo_ != nullptr;
}
inline bool C_ENTER_GAME::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& C_ENTER_GAME::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = _impl_.objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& C_ENTER_GAME::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_GAME.objectInfo)
  return _internal_objectinfo();
}
inline void C_ENTER_GAME::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectinfo_);
  }
  _impl_.objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_ENTER_GAME.objectInfo)
}
inline ::Protocol::ObjectInfo* C_ENTER_GAME::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = _impl_.objectinfo_;
  _impl_.objectinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* C_ENTER_GAME::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_ENTER_GAME.objectInfo)
  
  ::Protocol::ObjectInfo* temp = _impl_.objectinfo_;
  _impl_.objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* C_ENTER_GAME::_internal_mutable_objectinfo() {
  
  if (_impl_.objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.objectinfo_ = p;
  }
  return _impl_.objectinfo_;
}
inline ::Protocol::ObjectInfo* C_ENTER_GAME::mutable_objectinfo() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_objectinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_ENTER_GAME.objectInfo)
  return _msg;
}
inline void C_ENTER_GAME::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_ENTER_GAME.objectInfo)
}

// -------------------------------------------------------------------

// C_ENTER_ROOM

// int32 mapId = 1;
inline void C_ENTER_ROOM::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t C_ENTER_ROOM::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t C_ENTER_ROOM::mapid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_ROOM.mapId)
  return _internal_mapid();
}
inline void C_ENTER_ROOM::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void C_ENTER_ROOM::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER_ROOM.mapId)
}

// -------------------------------------------------------------------

// S_ENTER_ROOM

// .Protocol.ObjectInfo player = 1;
inline bool S_ENTER_ROOM::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool S_ENTER_ROOM::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::ObjectInfo& S_ENTER_ROOM::_internal_player() const {
  const ::Protocol::ObjectInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_ENTER_ROOM::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_ROOM.player)
  return _internal_player();
}
inline void S_ENTER_ROOM::unsafe_arena_set_allocated_player(
    ::Protocol::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ENTER_ROOM.player)
}
inline ::Protocol::ObjectInfo* S_ENTER_ROOM::release_player() {
  
  ::Protocol::ObjectInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_ENTER_ROOM::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER_ROOM.player)
  
  ::Protocol::ObjectInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_ENTER_ROOM::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::ObjectInfo* S_ENTER_ROOM::mutable_player() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_ROOM.player)
  return _msg;
}
inline void S_ENTER_ROOM::set_allocated_player(::Protocol::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER_ROOM.player)
}

// int32 mapId = 2;
inline void S_ENTER_ROOM::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t S_ENTER_ROOM::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t S_ENTER_ROOM::mapid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_ROOM.mapId)
  return _internal_mapid();
}
inline void S_ENTER_ROOM::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void S_ENTER_ROOM::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER_ROOM.mapId)
}

// -------------------------------------------------------------------

// C_LEAVE_GAME

// -------------------------------------------------------------------

// S_LEAVE_ROOM

// int32 objectId = 1;
inline void S_LEAVE_ROOM::clear_objectid() {
  _impl_.objectid_ = 0;
}
inline int32_t S_LEAVE_ROOM::_internal_objectid() const {
  return _impl_.objectid_;
}
inline int32_t S_LEAVE_ROOM::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LEAVE_ROOM.objectId)
  return _internal_objectid();
}
inline void S_LEAVE_ROOM::_internal_set_objectid(int32_t value) {
  
  _impl_.objectid_ = value;
}
inline void S_LEAVE_ROOM::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LEAVE_ROOM.objectId)
}

// -------------------------------------------------------------------

// S_SPAWN

// repeated .Protocol.ObjectInfo objects = 1;
inline int S_SPAWN::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int S_SPAWN::objects_size() const {
  return _internal_objects_size();
}
inline ::Protocol::ObjectInfo* S_SPAWN::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.objects)
  return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_SPAWN::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.objects)
  return &_impl_.objects_;
}
inline const ::Protocol::ObjectInfo& S_SPAWN::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_SPAWN::objects(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.objects)
  return _internal_objects(index);
}
inline ::Protocol::ObjectInfo* S_SPAWN::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline ::Protocol::ObjectInfo* S_SPAWN::add_objects() {
  ::Protocol::ObjectInfo* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_SPAWN::objects() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.objects)
  return _impl_.objects_;
}

// -------------------------------------------------------------------

// S_DESPAWN

// repeated int32 objectIds = 1;
inline int S_DESPAWN::_internal_objectids_size() const {
  return _impl_.objectids_.size();
}
inline int S_DESPAWN::objectids_size() const {
  return _internal_objectids_size();
}
inline void S_DESPAWN::clear_objectids() {
  _impl_.objectids_.Clear();
}
inline int32_t S_DESPAWN::_internal_objectids(int index) const {
  return _impl_.objectids_.Get(index);
}
inline int32_t S_DESPAWN::objectids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_DESPAWN.objectIds)
  return _internal_objectids(index);
}
inline void S_DESPAWN::set_objectids(int index, int32_t value) {
  _impl_.objectids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_DESPAWN.objectIds)
}
inline void S_DESPAWN::_internal_add_objectids(int32_t value) {
  _impl_.objectids_.Add(value);
}
inline void S_DESPAWN::add_objectids(int32_t value) {
  _internal_add_objectids(value);
  // @@protoc_insertion_point(field_add:Protocol.S_DESPAWN.objectIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_DESPAWN::_internal_objectids() const {
  return _impl_.objectids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_DESPAWN::objectids() const {
  // @@protoc_insertion_point(field_list:Protocol.S_DESPAWN.objectIds)
  return _internal_objectids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_DESPAWN::_internal_mutable_objectids() {
  return &_impl_.objectids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_DESPAWN::mutable_objectids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_DESPAWN.objectIds)
  return _internal_mutable_objectids();
}

// -------------------------------------------------------------------

// C_MOVE

// .Protocol.PositionInfo posInfo = 1;
inline bool C_MOVE::_internal_has_posinfo() const {
  return this != internal_default_instance() && _impl_.posinfo_ != nullptr;
}
inline bool C_MOVE::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::Protocol::PositionInfo& C_MOVE::_internal_posinfo() const {
  const ::Protocol::PositionInfo* p = _impl_.posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& C_MOVE::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVE.posInfo)
  return _internal_posinfo();
}
inline void C_MOVE::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  _impl_.posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_MOVE.posInfo)
}
inline ::Protocol::PositionInfo* C_MOVE::release_posinfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* C_MOVE::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_MOVE.posInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* C_MOVE::_internal_mutable_posinfo() {
  
  if (_impl_.posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.posinfo_ = p;
  }
  return _impl_.posinfo_;
}
inline ::Protocol::PositionInfo* C_MOVE::mutable_posinfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_MOVE.posInfo)
  return _msg;
}
inline void C_MOVE::set_allocated_posinfo(::Protocol::PositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_MOVE.posInfo)
}

// uint64 timeStamp = 3;
inline void C_MOVE::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t C_MOVE::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t C_MOVE::timestamp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVE.timeStamp)
  return _internal_timestamp();
}
inline void C_MOVE::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void C_MOVE::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_MOVE.timeStamp)
}

// -------------------------------------------------------------------

// S_MOVE

// int32 objectId = 1;
inline void S_MOVE::clear_objectid() {
  _impl_.objectid_ = 0;
}
inline int32_t S_MOVE::_internal_objectid() const {
  return _impl_.objectid_;
}
inline int32_t S_MOVE::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.objectId)
  return _internal_objectid();
}
inline void S_MOVE::_internal_set_objectid(int32_t value) {
  
  _impl_.objectid_ = value;
}
inline void S_MOVE::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_MOVE.objectId)
}

// .Protocol.PositionInfo posInfo = 2;
inline bool S_MOVE::_internal_has_posinfo() const {
  return this != internal_default_instance() && _impl_.posinfo_ != nullptr;
}
inline bool S_MOVE::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::Protocol::PositionInfo& S_MOVE::_internal_posinfo() const {
  const ::Protocol::PositionInfo* p = _impl_.posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& S_MOVE::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.posInfo)
  return _internal_posinfo();
}
inline void S_MOVE::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  _impl_.posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MOVE.posInfo)
}
inline ::Protocol::PositionInfo* S_MOVE::release_posinfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* S_MOVE::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_MOVE.posInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* S_MOVE::_internal_mutable_posinfo() {
  
  if (_impl_.posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.posinfo_ = p;
  }
  return _impl_.posinfo_;
}
inline ::Protocol::PositionInfo* S_MOVE::mutable_posinfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_MOVE.posInfo)
  return _msg;
}
inline void S_MOVE::set_allocated_posinfo(::Protocol::PositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MOVE.posInfo)
}

// uint64 timeStamp = 3;
inline void S_MOVE::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t S_MOVE::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t S_MOVE::timestamp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.timeStamp)
  return _internal_timestamp();
}
inline void S_MOVE::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void S_MOVE::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_MOVE.timeStamp)
}

// -------------------------------------------------------------------

// C_POS_SYNC

// .Protocol.PositionInfo posInfo = 1;
inline bool C_POS_SYNC::_internal_has_posinfo() const {
  return this != internal_default_instance() && _impl_.posinfo_ != nullptr;
}
inline bool C_POS_SYNC::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::Protocol::PositionInfo& C_POS_SYNC::_internal_posinfo() const {
  const ::Protocol::PositionInfo* p = _impl_.posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& C_POS_SYNC::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_POS_SYNC.posInfo)
  return _internal_posinfo();
}
inline void C_POS_SYNC::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  _impl_.posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_POS_SYNC.posInfo)
}
inline ::Protocol::PositionInfo* C_POS_SYNC::release_posinfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* C_POS_SYNC::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_POS_SYNC.posInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* C_POS_SYNC::_internal_mutable_posinfo() {
  
  if (_impl_.posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.posinfo_ = p;
  }
  return _impl_.posinfo_;
}
inline ::Protocol::PositionInfo* C_POS_SYNC::mutable_posinfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_POS_SYNC.posInfo)
  return _msg;
}
inline void C_POS_SYNC::set_allocated_posinfo(::Protocol::PositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_POS_SYNC.posInfo)
}

// -------------------------------------------------------------------

// C_ATTACK

// float dirX = 1;
inline void C_ATTACK::clear_dirx() {
  _impl_.dirx_ = 0;
}
inline float C_ATTACK::_internal_dirx() const {
  return _impl_.dirx_;
}
inline float C_ATTACK::dirx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ATTACK.dirX)
  return _internal_dirx();
}
inline void C_ATTACK::_internal_set_dirx(float value) {
  
  _impl_.dirx_ = value;
}
inline void C_ATTACK::set_dirx(float value) {
  _internal_set_dirx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ATTACK.dirX)
}

// float dirZ = 2;
inline void C_ATTACK::clear_dirz() {
  _impl_.dirz_ = 0;
}
inline float C_ATTACK::_internal_dirz() const {
  return _impl_.dirz_;
}
inline float C_ATTACK::dirz() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ATTACK.dirZ)
  return _internal_dirz();
}
inline void C_ATTACK::_internal_set_dirz(float value) {
  
  _impl_.dirz_ = value;
}
inline void C_ATTACK::set_dirz(float value) {
  _internal_set_dirz(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ATTACK.dirZ)
}

// -------------------------------------------------------------------

// S_ATTACK

// int32 attackerId = 1;
inline void S_ATTACK::clear_attackerid() {
  _impl_.attackerid_ = 0;
}
inline int32_t S_ATTACK::_internal_attackerid() const {
  return _impl_.attackerid_;
}
inline int32_t S_ATTACK::attackerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACK.attackerId)
  return _internal_attackerid();
}
inline void S_ATTACK::_internal_set_attackerid(int32_t value) {
  
  _impl_.attackerid_ = value;
}
inline void S_ATTACK::set_attackerid(int32_t value) {
  _internal_set_attackerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ATTACK.attackerId)
}

// float dirX = 2;
inline void S_ATTACK::clear_dirx() {
  _impl_.dirx_ = 0;
}
inline float S_ATTACK::_internal_dirx() const {
  return _impl_.dirx_;
}
inline float S_ATTACK::dirx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACK.dirX)
  return _internal_dirx();
}
inline void S_ATTACK::_internal_set_dirx(float value) {
  
  _impl_.dirx_ = value;
}
inline void S_ATTACK::set_dirx(float value) {
  _internal_set_dirx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ATTACK.dirX)
}

// float dirZ = 3;
inline void S_ATTACK::clear_dirz() {
  _impl_.dirz_ = 0;
}
inline float S_ATTACK::_internal_dirz() const {
  return _impl_.dirz_;
}
inline float S_ATTACK::dirz() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACK.dirZ)
  return _internal_dirz();
}
inline void S_ATTACK::_internal_set_dirz(float value) {
  
  _impl_.dirz_ = value;
}
inline void S_ATTACK::set_dirz(float value) {
  _internal_set_dirz(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ATTACK.dirZ)
}

// -------------------------------------------------------------------

// S_UPDATE_RESOURCE

// int32 objectId = 1;
inline void S_UPDATE_RESOURCE::clear_objectid() {
  _impl_.objectid_ = 0;
}
inline int32_t S_UPDATE_RESOURCE::_internal_objectid() const {
  return _impl_.objectid_;
}
inline int32_t S_UPDATE_RESOURCE::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UPDATE_RESOURCE.objectId)
  return _internal_objectid();
}
inline void S_UPDATE_RESOURCE::_internal_set_objectid(int32_t value) {
  
  _impl_.objectid_ = value;
}
inline void S_UPDATE_RESOURCE::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UPDATE_RESOURCE.objectId)
}

// int32 nowValue = 2;
inline void S_UPDATE_RESOURCE::clear_nowvalue() {
  _impl_.nowvalue_ = 0;
}
inline int32_t S_UPDATE_RESOURCE::_internal_nowvalue() const {
  return _impl_.nowvalue_;
}
inline int32_t S_UPDATE_RESOURCE::nowvalue() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UPDATE_RESOURCE.nowValue)
  return _internal_nowvalue();
}
inline void S_UPDATE_RESOURCE::_internal_set_nowvalue(int32_t value) {
  
  _impl_.nowvalue_ = value;
}
inline void S_UPDATE_RESOURCE::set_nowvalue(int32_t value) {
  _internal_set_nowvalue(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UPDATE_RESOURCE.nowValue)
}

// int32 changeValue = 3;
inline void S_UPDATE_RESOURCE::clear_changevalue() {
  _impl_.changevalue_ = 0;
}
inline int32_t S_UPDATE_RESOURCE::_internal_changevalue() const {
  return _impl_.changevalue_;
}
inline int32_t S_UPDATE_RESOURCE::changevalue() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UPDATE_RESOURCE.changeValue)
  return _internal_changevalue();
}
inline void S_UPDATE_RESOURCE::_internal_set_changevalue(int32_t value) {
  
  _impl_.changevalue_ = value;
}
inline void S_UPDATE_RESOURCE::set_changevalue(int32_t value) {
  _internal_set_changevalue(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UPDATE_RESOURCE.changeValue)
}

// .Protocol.ResourceType type = 4;
inline void S_UPDATE_RESOURCE::clear_type() {
  _impl_.type_ = 0;
}
inline ::Protocol::ResourceType S_UPDATE_RESOURCE::_internal_type() const {
  return static_cast< ::Protocol::ResourceType >(_impl_.type_);
}
inline ::Protocol::ResourceType S_UPDATE_RESOURCE::type() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UPDATE_RESOURCE.type)
  return _internal_type();
}
inline void S_UPDATE_RESOURCE::_internal_set_type(::Protocol::ResourceType value) {
  
  _impl_.type_ = value;
}
inline void S_UPDATE_RESOURCE::set_type(::Protocol::ResourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UPDATE_RESOURCE.type)
}

// -------------------------------------------------------------------

// S_DIE

// int32 objectId = 1;
inline void S_DIE::clear_objectid() {
  _impl_.objectid_ = 0;
}
inline int32_t S_DIE::_internal_objectid() const {
  return _impl_.objectid_;
}
inline int32_t S_DIE::objectid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DIE.objectId)
  return _internal_objectid();
}
inline void S_DIE::_internal_set_objectid(int32_t value) {
  
  _impl_.objectid_ = value;
}
inline void S_DIE::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DIE.objectId)
}

// int32 attackerId = 2;
inline void S_DIE::clear_attackerid() {
  _impl_.attackerid_ = 0;
}
inline int32_t S_DIE::_internal_attackerid() const {
  return _impl_.attackerid_;
}
inline int32_t S_DIE::attackerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DIE.attackerId)
  return _internal_attackerid();
}
inline void S_DIE::_internal_set_attackerid(int32_t value) {
  
  _impl_.attackerid_ = value;
}
inline void S_DIE::set_attackerid(int32_t value) {
  _internal_set_attackerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DIE.attackerId)
}

// -------------------------------------------------------------------

// S_PING

// uint64 timeStamp = 1;
inline void S_PING::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t S_PING::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t S_PING::timestamp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PING.timeStamp)
  return _internal_timestamp();
}
inline void S_PING::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void S_PING::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PING.timeStamp)
}

// -------------------------------------------------------------------

// C_PONG

// uint64 timeStamp = 1;
inline void C_PONG::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t C_PONG::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t C_PONG::timestamp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PONG.timeStamp)
  return _internal_timestamp();
}
inline void C_PONG::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void C_PONG::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PONG.timeStamp)
}

// -------------------------------------------------------------------

// S_USER_STATUS

// .Protocol.PlayerInfo playerData = 1;
inline bool S_USER_STATUS::_internal_has_playerdata() const {
  return this != internal_default_instance() && _impl_.playerdata_ != nullptr;
}
inline bool S_USER_STATUS::has_playerdata() const {
  return _internal_has_playerdata();
}
inline const ::Protocol::PlayerInfo& S_USER_STATUS::_internal_playerdata() const {
  const ::Protocol::PlayerInfo* p = _impl_.playerdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PlayerInfo&>(
      ::Protocol::_PlayerInfo_default_instance_);
}
inline const ::Protocol::PlayerInfo& S_USER_STATUS::playerdata() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USER_STATUS.playerData)
  return _internal_playerdata();
}
inline void S_USER_STATUS::unsafe_arena_set_allocated_playerdata(
    ::Protocol::PlayerInfo* playerdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playerdata_);
  }
  _impl_.playerdata_ = playerdata;
  if (playerdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_USER_STATUS.playerData)
}
inline ::Protocol::PlayerInfo* S_USER_STATUS::release_playerdata() {
  
  ::Protocol::PlayerInfo* temp = _impl_.playerdata_;
  _impl_.playerdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PlayerInfo* S_USER_STATUS::unsafe_arena_release_playerdata() {
  // @@protoc_insertion_point(field_release:Protocol.S_USER_STATUS.playerData)
  
  ::Protocol::PlayerInfo* temp = _impl_.playerdata_;
  _impl_.playerdata_ = nullptr;
  return temp;
}
inline ::Protocol::PlayerInfo* S_USER_STATUS::_internal_mutable_playerdata() {
  
  if (_impl_.playerdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PlayerInfo>(GetArenaForAllocation());
    _impl_.playerdata_ = p;
  }
  return _impl_.playerdata_;
}
inline ::Protocol::PlayerInfo* S_USER_STATUS::mutable_playerdata() {
  ::Protocol::PlayerInfo* _msg = _internal_mutable_playerdata();
  // @@protoc_insertion_point(field_mutable:Protocol.S_USER_STATUS.playerData)
  return _msg;
}
inline void S_USER_STATUS::set_allocated_playerdata(::Protocol::PlayerInfo* playerdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playerdata_);
  }
  if (playerdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerdata));
    if (message_arena != submessage_arena) {
      playerdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.playerdata_ = playerdata;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_USER_STATUS.playerData)
}

// -------------------------------------------------------------------

// S_ITEM_LIST

// repeated .Protocol.ItemInfo items = 1;
inline int S_ITEM_LIST::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int S_ITEM_LIST::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemInfo* S_ITEM_LIST::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ITEM_LIST.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
S_ITEM_LIST::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_ITEM_LIST.items)
  return &_impl_.items_;
}
inline const ::Protocol::ItemInfo& S_ITEM_LIST::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ItemInfo& S_ITEM_LIST::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_ITEM_LIST.items)
  return _internal_items(index);
}
inline ::Protocol::ItemInfo* S_ITEM_LIST::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ItemInfo* S_ITEM_LIST::add_items() {
  ::Protocol::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_ITEM_LIST.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
S_ITEM_LIST::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_ITEM_LIST.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// S_ADD_ITEM

// repeated .Protocol.ItemInfo items = 1;
inline int S_ADD_ITEM::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int S_ADD_ITEM::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemInfo* S_ADD_ITEM::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ADD_ITEM.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
S_ADD_ITEM::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_ADD_ITEM.items)
  return &_impl_.items_;
}
inline const ::Protocol::ItemInfo& S_ADD_ITEM::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ItemInfo& S_ADD_ITEM::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_ADD_ITEM.items)
  return _internal_items(index);
}
inline ::Protocol::ItemInfo* S_ADD_ITEM::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ItemInfo* S_ADD_ITEM::add_items() {
  ::Protocol::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_ADD_ITEM.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
S_ADD_ITEM::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_ADD_ITEM.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// S_CHANGE_CURRENCY

// .Protocol.CurrencyType currencyType = 1;
inline void S_CHANGE_CURRENCY::clear_currencytype() {
  _impl_.currencytype_ = 0;
}
inline ::Protocol::CurrencyType S_CHANGE_CURRENCY::_internal_currencytype() const {
  return static_cast< ::Protocol::CurrencyType >(_impl_.currencytype_);
}
inline ::Protocol::CurrencyType S_CHANGE_CURRENCY::currencytype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHANGE_CURRENCY.currencyType)
  return _internal_currencytype();
}
inline void S_CHANGE_CURRENCY::_internal_set_currencytype(::Protocol::CurrencyType value) {
  
  _impl_.currencytype_ = value;
}
inline void S_CHANGE_CURRENCY::set_currencytype(::Protocol::CurrencyType value) {
  _internal_set_currencytype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHANGE_CURRENCY.currencyType)
}

// int32 changeAmount = 2;
inline void S_CHANGE_CURRENCY::clear_changeamount() {
  _impl_.changeamount_ = 0;
}
inline int32_t S_CHANGE_CURRENCY::_internal_changeamount() const {
  return _impl_.changeamount_;
}
inline int32_t S_CHANGE_CURRENCY::changeamount() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHANGE_CURRENCY.changeAmount)
  return _internal_changeamount();
}
inline void S_CHANGE_CURRENCY::_internal_set_changeamount(int32_t value) {
  
  _impl_.changeamount_ = value;
}
inline void S_CHANGE_CURRENCY::set_changeamount(int32_t value) {
  _internal_set_changeamount(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHANGE_CURRENCY.changeAmount)
}

// int32 totalAmount = 3;
inline void S_CHANGE_CURRENCY::clear_totalamount() {
  _impl_.totalamount_ = 0;
}
inline int32_t S_CHANGE_CURRENCY::_internal_totalamount() const {
  return _impl_.totalamount_;
}
inline int32_t S_CHANGE_CURRENCY::totalamount() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHANGE_CURRENCY.totalAmount)
  return _internal_totalamount();
}
inline void S_CHANGE_CURRENCY::_internal_set_totalamount(int32_t value) {
  
  _impl_.totalamount_ = value;
}
inline void S_CHANGE_CURRENCY::set_totalamount(int32_t value) {
  _internal_set_totalamount(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHANGE_CURRENCY.totalAmount)
}

// -------------------------------------------------------------------

// C_SKILL

// .Protocol.PositionInfo posInfo = 1;
inline bool C_SKILL::_internal_has_posinfo() const {
  return this != internal_default_instance() && _impl_.posinfo_ != nullptr;
}
inline bool C_SKILL::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::Protocol::PositionInfo& C_SKILL::_internal_posinfo() const {
  const ::Protocol::PositionInfo* p = _impl_.posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& C_SKILL::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SKILL.posInfo)
  return _internal_posinfo();
}
inline void C_SKILL::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  _impl_.posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_SKILL.posInfo)
}
inline ::Protocol::PositionInfo* C_SKILL::release_posinfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* C_SKILL::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_SKILL.posInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* C_SKILL::_internal_mutable_posinfo() {
  
  if (_impl_.posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.posinfo_ = p;
  }
  return _impl_.posinfo_;
}
inline ::Protocol::PositionInfo* C_SKILL::mutable_posinfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_SKILL.posInfo)
  return _msg;
}
inline void C_SKILL::set_allocated_posinfo(::Protocol::PositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_SKILL.posInfo)
}

// int32 skillTemplateId = 2;
inline void C_SKILL::clear_skilltemplateid() {
  _impl_.skilltemplateid_ = 0;
}
inline int32_t C_SKILL::_internal_skilltemplateid() const {
  return _impl_.skilltemplateid_;
}
inline int32_t C_SKILL::skilltemplateid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SKILL.skillTemplateId)
  return _internal_skilltemplateid();
}
inline void C_SKILL::_internal_set_skilltemplateid(int32_t value) {
  
  _impl_.skilltemplateid_ = value;
}
inline void C_SKILL::set_skilltemplateid(int32_t value) {
  _internal_set_skilltemplateid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SKILL.skillTemplateId)
}

// -------------------------------------------------------------------

// S_SKILL

// bool success = 1;
inline void S_SKILL::clear_success() {
  _impl_.success_ = false;
}
inline bool S_SKILL::_internal_success() const {
  return _impl_.success_;
}
inline bool S_SKILL::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SKILL.success)
  return _internal_success();
}
inline void S_SKILL::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_SKILL::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SKILL.success)
}

// .Protocol.PositionInfo posInfo = 2;
inline bool S_SKILL::_internal_has_posinfo() const {
  return this != internal_default_instance() && _impl_.posinfo_ != nullptr;
}
inline bool S_SKILL::has_posinfo() const {
  return _internal_has_posinfo();
}
inline const ::Protocol::PositionInfo& S_SKILL::_internal_posinfo() const {
  const ::Protocol::PositionInfo* p = _impl_.posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& S_SKILL::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SKILL.posInfo)
  return _internal_posinfo();
}
inline void S_SKILL::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  _impl_.posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_SKILL.posInfo)
}
inline ::Protocol::PositionInfo* S_SKILL::release_posinfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* S_SKILL::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_SKILL.posInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.posinfo_;
  _impl_.posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* S_SKILL::_internal_mutable_posinfo() {
  
  if (_impl_.posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.posinfo_ = p;
  }
  return _impl_.posinfo_;
}
inline ::Protocol::PositionInfo* S_SKILL::mutable_posinfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_SKILL.posInfo)
  return _msg;
}
inline void S_SKILL::set_allocated_posinfo(::Protocol::PositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinfo_);
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo));
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_SKILL.posInfo)
}

// int32 skillTemplateId = 3;
inline void S_SKILL::clear_skilltemplateid() {
  _impl_.skilltemplateid_ = 0;
}
inline int32_t S_SKILL::_internal_skilltemplateid() const {
  return _impl_.skilltemplateid_;
}
inline int32_t S_SKILL::skilltemplateid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SKILL.skillTemplateId)
  return _internal_skilltemplateid();
}
inline void S_SKILL::_internal_set_skilltemplateid(int32_t value) {
  
  _impl_.skilltemplateid_ = value;
}
inline void S_SKILL::set_skilltemplateid(int32_t value) {
  _internal_set_skilltemplateid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SKILL.skillTemplateId)
}

// int32 attackerId = 4;
inline void S_SKILL::clear_attackerid() {
  _impl_.attackerid_ = 0;
}
inline int32_t S_SKILL::_internal_attackerid() const {
  return _impl_.attackerid_;
}
inline int32_t S_SKILL::attackerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SKILL.attackerId)
  return _internal_attackerid();
}
inline void S_SKILL::_internal_set_attackerid(int32_t value) {
  
  _impl_.attackerid_ = value;
}
inline void S_SKILL::set_attackerid(int32_t value) {
  _internal_set_attackerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SKILL.attackerId)
}

// -------------------------------------------------------------------

// C_USE_ITEM

// int32 itemDbId = 1;
inline void C_USE_ITEM::clear_itemdbid() {
  _impl_.itemdbid_ = 0;
}
inline int32_t C_USE_ITEM::_internal_itemdbid() const {
  return _impl_.itemdbid_;
}
inline int32_t C_USE_ITEM::itemdbid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_USE_ITEM.itemDbId)
  return _internal_itemdbid();
}
inline void C_USE_ITEM::_internal_set_itemdbid(int32_t value) {
  
  _impl_.itemdbid_ = value;
}
inline void C_USE_ITEM::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_USE_ITEM.itemDbId)
}

// -------------------------------------------------------------------

// S_CHANGE_ITEM_INFO

// repeated .Protocol.ItemInfo items = 1;
inline int S_CHANGE_ITEM_INFO::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int S_CHANGE_ITEM_INFO::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::ItemInfo* S_CHANGE_ITEM_INFO::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHANGE_ITEM_INFO.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
S_CHANGE_ITEM_INFO::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_CHANGE_ITEM_INFO.items)
  return &_impl_.items_;
}
inline const ::Protocol::ItemInfo& S_CHANGE_ITEM_INFO::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::ItemInfo& S_CHANGE_ITEM_INFO::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHANGE_ITEM_INFO.items)
  return _internal_items(index);
}
inline ::Protocol::ItemInfo* S_CHANGE_ITEM_INFO::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::ItemInfo* S_CHANGE_ITEM_INFO::add_items() {
  ::Protocol::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_CHANGE_ITEM_INFO.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
S_CHANGE_ITEM_INFO::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_CHANGE_ITEM_INFO.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// C_DROP_ITEM

// int32 itemDbId = 1;
inline void C_DROP_ITEM::clear_itemdbid() {
  _impl_.itemdbid_ = 0;
}
inline int32_t C_DROP_ITEM::_internal_itemdbid() const {
  return _impl_.itemdbid_;
}
inline int32_t C_DROP_ITEM::itemdbid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_DROP_ITEM.itemDbId)
  return _internal_itemdbid();
}
inline void C_DROP_ITEM::_internal_set_itemdbid(int32_t value) {
  
  _impl_.itemdbid_ = value;
}
inline void C_DROP_ITEM::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_DROP_ITEM.itemDbId)
}

// -------------------------------------------------------------------

// S_REMOVE_ITEM

// int32 removedItemDbID = 1;
inline void S_REMOVE_ITEM::clear_removeditemdbid() {
  _impl_.removeditemdbid_ = 0;
}
inline int32_t S_REMOVE_ITEM::_internal_removeditemdbid() const {
  return _impl_.removeditemdbid_;
}
inline int32_t S_REMOVE_ITEM::removeditemdbid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_REMOVE_ITEM.removedItemDbID)
  return _internal_removeditemdbid();
}
inline void S_REMOVE_ITEM::_internal_set_removeditemdbid(int32_t value) {
  
  _impl_.removeditemdbid_ = value;
}
inline void S_REMOVE_ITEM::set_removeditemdbid(int32_t value) {
  _internal_set_removeditemdbid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_REMOVE_ITEM.removedItemDbID)
}

// -------------------------------------------------------------------

// C_REQUEST_MARKET_ITEM_LIST

// -------------------------------------------------------------------

// S_MARKET_ITEM_LIST

// repeated .Protocol.MarketItemInfo items = 1;
inline int S_MARKET_ITEM_LIST::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int S_MARKET_ITEM_LIST::items_size() const {
  return _internal_items_size();
}
inline ::Protocol::MarketItemInfo* S_MARKET_ITEM_LIST::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_MARKET_ITEM_LIST.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MarketItemInfo >*
S_MARKET_ITEM_LIST::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_MARKET_ITEM_LIST.items)
  return &_impl_.items_;
}
inline const ::Protocol::MarketItemInfo& S_MARKET_ITEM_LIST::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::Protocol::MarketItemInfo& S_MARKET_ITEM_LIST::items(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_MARKET_ITEM_LIST.items)
  return _internal_items(index);
}
inline ::Protocol::MarketItemInfo* S_MARKET_ITEM_LIST::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::Protocol::MarketItemInfo* S_MARKET_ITEM_LIST::add_items() {
  ::Protocol::MarketItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:Protocol.S_MARKET_ITEM_LIST.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::MarketItemInfo >&
S_MARKET_ITEM_LIST::items() const {
  // @@protoc_insertion_point(field_list:Protocol.S_MARKET_ITEM_LIST.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// C_PURCHASE_MARKET_ITEM

// int32 itemdDbId = 1;
inline void C_PURCHASE_MARKET_ITEM::clear_itemddbid() {
  _impl_.itemddbid_ = 0;
}
inline int32_t C_PURCHASE_MARKET_ITEM::_internal_itemddbid() const {
  return _impl_.itemddbid_;
}
inline int32_t C_PURCHASE_MARKET_ITEM::itemddbid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PURCHASE_MARKET_ITEM.itemdDbId)
  return _internal_itemddbid();
}
inline void C_PURCHASE_MARKET_ITEM::_internal_set_itemddbid(int32_t value) {
  
  _impl_.itemddbid_ = value;
}
inline void C_PURCHASE_MARKET_ITEM::set_itemddbid(int32_t value) {
  _internal_set_itemddbid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PURCHASE_MARKET_ITEM.itemdDbId)
}

// -------------------------------------------------------------------

// C_REGISTER_MARKET_ITEM

// int32 itemdDbId = 1;
inline void C_REGISTER_MARKET_ITEM::clear_itemddbid() {
  _impl_.itemddbid_ = 0;
}
inline int32_t C_REGISTER_MARKET_ITEM::_internal_itemddbid() const {
  return _impl_.itemddbid_;
}
inline int32_t C_REGISTER_MARKET_ITEM::itemddbid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_REGISTER_MARKET_ITEM.itemdDbId)
  return _internal_itemddbid();
}
inline void C_REGISTER_MARKET_ITEM::_internal_set_itemddbid(int32_t value) {
  
  _impl_.itemddbid_ = value;
}
inline void C_REGISTER_MARKET_ITEM::set_itemddbid(int32_t value) {
  _internal_set_itemddbid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_REGISTER_MARKET_ITEM.itemdDbId)
}

// int32 cost = 2;
inline void C_REGISTER_MARKET_ITEM::clear_cost() {
  _impl_.cost_ = 0;
}
inline int32_t C_REGISTER_MARKET_ITEM::_internal_cost() const {
  return _impl_.cost_;
}
inline int32_t C_REGISTER_MARKET_ITEM::cost() const {
  // @@protoc_insertion_point(field_get:Protocol.C_REGISTER_MARKET_ITEM.cost)
  return _internal_cost();
}
inline void C_REGISTER_MARKET_ITEM::_internal_set_cost(int32_t value) {
  
  _impl_.cost_ = value;
}
inline void C_REGISTER_MARKET_ITEM::set_cost(int32_t value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:Protocol.C_REGISTER_MARKET_ITEM.cost)
}

// -------------------------------------------------------------------

// S_PURCHASE_MARKET_ITEM

// bool result = 1;
inline void S_PURCHASE_MARKET_ITEM::clear_result() {
  _impl_.result_ = false;
}
inline bool S_PURCHASE_MARKET_ITEM::_internal_result() const {
  return _impl_.result_;
}
inline bool S_PURCHASE_MARKET_ITEM::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PURCHASE_MARKET_ITEM.result)
  return _internal_result();
}
inline void S_PURCHASE_MARKET_ITEM::_internal_set_result(bool value) {
  
  _impl_.result_ = value;
}
inline void S_PURCHASE_MARKET_ITEM::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PURCHASE_MARKET_ITEM.result)
}

// .Protocol.ItemInfo items = 2;
inline bool S_PURCHASE_MARKET_ITEM::_internal_has_items() const {
  return this != internal_default_instance() && _impl_.items_ != nullptr;
}
inline bool S_PURCHASE_MARKET_ITEM::has_items() const {
  return _internal_has_items();
}
inline const ::Protocol::ItemInfo& S_PURCHASE_MARKET_ITEM::_internal_items() const {
  const ::Protocol::ItemInfo* p = _impl_.items_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ItemInfo&>(
      ::Protocol::_ItemInfo_default_instance_);
}
inline const ::Protocol::ItemInfo& S_PURCHASE_MARKET_ITEM::items() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PURCHASE_MARKET_ITEM.items)
  return _internal_items();
}
inline void S_PURCHASE_MARKET_ITEM::unsafe_arena_set_allocated_items(
    ::Protocol::ItemInfo* items) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.items_);
  }
  _impl_.items_ = items;
  if (items) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_PURCHASE_MARKET_ITEM.items)
}
inline ::Protocol::ItemInfo* S_PURCHASE_MARKET_ITEM::release_items() {
  
  ::Protocol::ItemInfo* temp = _impl_.items_;
  _impl_.items_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ItemInfo* S_PURCHASE_MARKET_ITEM::unsafe_arena_release_items() {
  // @@protoc_insertion_point(field_release:Protocol.S_PURCHASE_MARKET_ITEM.items)
  
  ::Protocol::ItemInfo* temp = _impl_.items_;
  _impl_.items_ = nullptr;
  return temp;
}
inline ::Protocol::ItemInfo* S_PURCHASE_MARKET_ITEM::_internal_mutable_items() {
  
  if (_impl_.items_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ItemInfo>(GetArenaForAllocation());
    _impl_.items_ = p;
  }
  return _impl_.items_;
}
inline ::Protocol::ItemInfo* S_PURCHASE_MARKET_ITEM::mutable_items() {
  ::Protocol::ItemInfo* _msg = _internal_mutable_items();
  // @@protoc_insertion_point(field_mutable:Protocol.S_PURCHASE_MARKET_ITEM.items)
  return _msg;
}
inline void S_PURCHASE_MARKET_ITEM::set_allocated_items(::Protocol::ItemInfo* items) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.items_);
  }
  if (items) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(items));
    if (message_arena != submessage_arena) {
      items = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, items, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.items_ = items;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_PURCHASE_MARKET_ITEM.items)
}

// -------------------------------------------------------------------

// C_CHAT

// string message = 1;
inline void C_CHAT::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& C_CHAT::message() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHAT.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CHAT::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CHAT.message)
}
inline std::string* C_CHAT::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CHAT.message)
  return _s;
}
inline const std::string& C_CHAT::_internal_message() const {
  return _impl_.message_.Get();
}
inline void C_CHAT::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CHAT::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CHAT::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.C_CHAT.message)
  return _impl_.message_.Release();
}
inline void C_CHAT::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CHAT.message)
}

// int32 senderId = 2;
inline void C_CHAT::clear_senderid() {
  _impl_.senderid_ = 0;
}
inline int32_t C_CHAT::_internal_senderid() const {
  return _impl_.senderid_;
}
inline int32_t C_CHAT::senderid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHAT.senderId)
  return _internal_senderid();
}
inline void C_CHAT::_internal_set_senderid(int32_t value) {
  
  _impl_.senderid_ = value;
}
inline void C_CHAT::set_senderid(int32_t value) {
  _internal_set_senderid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CHAT.senderId)
}

// -------------------------------------------------------------------

// S_CHAT

// string prefix = 1;
inline void S_CHAT::clear_prefix() {
  _impl_.prefix_.ClearToEmpty();
}
inline const std::string& S_CHAT::prefix() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHAT::set_prefix(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prefix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.prefix)
}
inline std::string* S_CHAT::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHAT.prefix)
  return _s;
}
inline const std::string& S_CHAT::_internal_prefix() const {
  return _impl_.prefix_.Get();
}
inline void S_CHAT::_internal_set_prefix(const std::string& value) {
  
  _impl_.prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CHAT::_internal_mutable_prefix() {
  
  return _impl_.prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CHAT::release_prefix() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHAT.prefix)
  return _impl_.prefix_.Release();
}
inline void S_CHAT::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  _impl_.prefix_.SetAllocated(prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prefix_.IsDefault()) {
    _impl_.prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHAT.prefix)
}

// string content = 2;
inline void S_CHAT::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& S_CHAT::content() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHAT::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.content)
}
inline std::string* S_CHAT::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHAT.content)
  return _s;
}
inline const std::string& S_CHAT::_internal_content() const {
  return _impl_.content_.Get();
}
inline void S_CHAT::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CHAT::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CHAT::release_content() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHAT.content)
  return _impl_.content_.Release();
}
inline void S_CHAT::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHAT.content)
}

// .Protocol.ChatType type = 3;
inline void S_CHAT::clear_type() {
  _impl_.type_ = 0;
}
inline ::Protocol::ChatType S_CHAT::_internal_type() const {
  return static_cast< ::Protocol::ChatType >(_impl_.type_);
}
inline ::Protocol::ChatType S_CHAT::type() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.type)
  return _internal_type();
}
inline void S_CHAT::_internal_set_type(::Protocol::ChatType value) {
  
  _impl_.type_ = value;
}
inline void S_CHAT::set_type(::Protocol::ChatType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.type)
}

// int32 senderId = 4;
inline void S_CHAT::clear_senderid() {
  _impl_.senderid_ = 0;
}
inline int32_t S_CHAT::_internal_senderid() const {
  return _impl_.senderid_;
}
inline int32_t S_CHAT::senderid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.senderId)
  return _internal_senderid();
}
inline void S_CHAT::_internal_set_senderid(int32_t value) {
  
  _impl_.senderid_ = value;
}
inline void S_CHAT::set_senderid(int32_t value) {
  _internal_set_senderid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.senderId)
}

// -------------------------------------------------------------------

// C_WHISPER

// string receiverName = 1;
inline void C_WHISPER::clear_receivername() {
  _impl_.receivername_.ClearToEmpty();
}
inline const std::string& C_WHISPER::receivername() const {
  // @@protoc_insertion_point(field_get:Protocol.C_WHISPER.receiverName)
  return _internal_receivername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_WHISPER::set_receivername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.receivername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_WHISPER.receiverName)
}
inline std::string* C_WHISPER::mutable_receivername() {
  std::string* _s = _internal_mutable_receivername();
  // @@protoc_insertion_point(field_mutable:Protocol.C_WHISPER.receiverName)
  return _s;
}
inline const std::string& C_WHISPER::_internal_receivername() const {
  return _impl_.receivername_.Get();
}
inline void C_WHISPER::_internal_set_receivername(const std::string& value) {
  
  _impl_.receivername_.Set(value, GetArenaForAllocation());
}
inline std::string* C_WHISPER::_internal_mutable_receivername() {
  
  return _impl_.receivername_.Mutable(GetArenaForAllocation());
}
inline std::string* C_WHISPER::release_receivername() {
  // @@protoc_insertion_point(field_release:Protocol.C_WHISPER.receiverName)
  return _impl_.receivername_.Release();
}
inline void C_WHISPER::set_allocated_receivername(std::string* receivername) {
  if (receivername != nullptr) {
    
  } else {
    
  }
  _impl_.receivername_.SetAllocated(receivername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.receivername_.IsDefault()) {
    _impl_.receivername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_WHISPER.receiverName)
}

// string message = 2;
inline void C_WHISPER::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& C_WHISPER::message() const {
  // @@protoc_insertion_point(field_get:Protocol.C_WHISPER.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_WHISPER::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_WHISPER.message)
}
inline std::string* C_WHISPER::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Protocol.C_WHISPER.message)
  return _s;
}
inline const std::string& C_WHISPER::_internal_message() const {
  return _impl_.message_.Get();
}
inline void C_WHISPER::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* C_WHISPER::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* C_WHISPER::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.C_WHISPER.message)
  return _impl_.message_.Release();
}
inline void C_WHISPER::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_WHISPER.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
